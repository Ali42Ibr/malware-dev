/* 

 GetModuleHandle/GetProcAddress are widely used for call obfuscation as they can reduce anti-viruses' 
 static analysis capabilities.

 AVs will generally search for a combination of dangerous functions ran 
 and conclude (sometimes incorrectly) that the PE is malicious. Looking at a PE's import table will easily reveal
 what external functions the executable is trying to call. Normally, the name of the required library and functions 
 will appear in this import table, and can be easily caught. GetModuleHandle/GetProcAddress combo will instead dynamically
 retrieve the adresses of required libraries and functions at runtime, therefore hiding the call from the PE until
 it is ran. 

 This file consists of two custom implementations of GetProcAddress and GetModuleHandle.
 They can defintely be improved, I just wrote them to better understand PE headers, and get some practice parsing structures 
 such as the export/import tables and PEB/TEB.

 This implementation was inspired by Sektor7's RED TEAM Operator: Malware Development Intermediate Course.
 
*/

#include <stdio.h>
#include <windows.h>
#include "callobs.h"

typedef HMODULE (WINAPI * cLoadLibrary)(LPCSTR lpFileName);
cLoadLibrary pLoadLibraryA = NULL;

HMODULE WINAPI cGetModuleHandle(LPCWSTR moduleName) {
		
	HMODULE modulePointer;
	
	//PEB base address retrieved from TEB
	#ifdef _M_IX86 
	PEB * pPEB = (PEB *) __readfsdword(0x30);
	#else
	PEB * pPEB = (PEB *)__readgsqword(0x60);
	#endif
	
	//return calling module's base address if no name provided
	if (moduleName == NULL)
		return (HMODULE) pPEB->ImageBaseAddress;

	//searching through Ldr for a matching DllName
	PEB_LDR_DATA * pLdr = pPEB->Ldr;
	
	LIST_ENTRY * pModuleList = &pLdr->InMemoryOrderModuleList;
	LIST_ENTRY * pLDTEntry = pModuleList->Flink;
	
	for (LIST_ENTRY * nextEntry = pLDTEntry; nextEntry != pModuleList; nextEntry = nextEntry->Flink){
		LDR_DATA_TABLE_ENTRY * pEntry = (LDR_DATA_TABLE_ENTRY *) ((BYTE *) nextEntry - sizeof(LIST_ENTRY));
		if (lstrcmpiW(pEntry->BaseDllName.Buffer, moduleName) == 0){
			modulePointer = (HMODULE) pEntry->DllBase;
			return modulePointer;
		}
	}

	return NULL;


}

FARPROC WINAPI cGetProcAddress( HMODULE hModule, LPCSTR lpProcName){
	
	char * reqFunction = (char *) lpProcName;
	char * baseAddr = (char *) hModule;
	
	FARPROC procAddress;
	
	//parse headers to find function addresses
	IMAGE_DOS_HEADER * dos_header = (IMAGE_DOS_HEADER *) baseAddr;
	IMAGE_NT_HEADERS * nt_header = (IMAGE_NT_HEADERS *) (dos_header->e_lfanew + baseAddr);
	IMAGE_OPTIONAL_HEADER * optional_header = (IMAGE_OPTIONAL_HEADER *) &nt_header->OptionalHeader;
	IMAGE_DATA_DIRECTORY * export_data_directory = &optional_header->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
	IMAGE_EXPORT_DIRECTORY * export_directory = (IMAGE_EXPORT_DIRECTORY *) (export_data_directory->VirtualAddress + baseAddr);
	
	DWORD numOfNames = export_directory->NumberOfNames;
	DWORD * funcNamesAddress = (DWORD *) (export_directory->AddressOfNames + baseAddr);
	DWORD * funcAddress = (DWORD *) (export_directory->AddressOfFunctions + baseAddr);

	char * stringAddress;
	
	//finding index of function
	int indexForFunction;
	for (int i = 0; i < numOfNames; i++){
		stringAddress = baseAddr + funcNamesAddress[i];
		if (strcmp(stringAddress, reqFunction) == 0){
			procAddress = (FARPROC) (funcAddress[i] + baseAddr);			
		}
	}
	
	
	//check if function requires forwarding
	if ( (char *) procAddress > (char *) export_directory && (char *) procAddress <= (char *)(export_directory + export_data_directory->Size)) { 
		
		//seperate function name and library name (library.function)
		
		int chrCount = 0;
		char * dllName;
		char * funcName;
		char * stringCopy = _strdup((char *) procAddress);
		HMODULE libAddress;
		
		while (stringCopy[chrCount] != '.')
			chrCount++;
				
		stringCopy[chrCount] = 0x00;
		chrCount++;
		
		dllName = stringCopy;
		
		//init LoadLibrary function
		pLoadLibraryA = (cLoadLibrary) cGetProcAddress(cGetModuleHandle(L"Kernel32.dll"),"LoadLibraryA");
		
		//load the dll and call the function 
		libAddress = pLoadLibraryA((LPSTR) dllName);
		funcName = stringCopy+chrCount;		
		procAddress = cGetProcAddress(libAddress, stringCopy);
		
		free(stringCopy);			
		if (!libAddress) return NULL;

	}
	
	return procAddress;
	
	
}