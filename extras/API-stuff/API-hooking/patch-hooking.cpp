/*

 API hooking techniques are used in a variety of malware, anti-virus, and a variety of other applications. 
 These techniques involve controlling or redirecting function behaviour such as that the code execution is 
 completely different than what it should be. 
 
 API hooking is ued in EDRs by checking the parameters and usage of specific potentially dangerous function.
 But fortunately, since these EDRs are in user-space we have just as much control over these functions as they do.
 So by simply redirecting the EDRs redirection, we can revert its control and bypass it. This is just one of the 
 many scenarios where API hooking is useful.

 This method patches the first few instructions of the old function to redirect execution to the new function.   
 This is done at runtime, and the original function bytes are saved so it can be repatched incase it is to be 
 reused.

 Compile as dll and attatch/inject into victim process.

*/

#include <windows.h>
#include <stdio.h>
#pragma comment(lib, "user32.lib")

#define TOTAL_BYTES 14

int (WINAPI * pMessageBox)(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType) = MessageBox;
unsigned char deletedBytes[TOTAL_BYTES];
DWORD oldProtect = NULL;
int patchingHook(void * functionName, void * newFunctionName);

// function which replaces hooked function
int otherFunc(){

	printf("MessageBox execution in shambles\n");
	
	//can delete this if original function not required
	VirtualProtect((LPVOID) MessageBox, 4096, PAGE_READWRITE, &oldProtect);
	memcpy( MessageBox, deletedBytes, TOTAL_BYTES); 
	VirtualProtect((LPVOID) MessageBox, 4096, oldProtect, &oldProtect);	
	MessageBox( NULL, "Fixed box", "123", MB_OK);
	
	patchingHook( pMessageBox, otherFunc);
	
	return 0;

}

// does the hooking
int patchingHook(void * functionName, void * newFunctionName){
				
	// opcode for JMP [RIP + 0]
	unsigned char detour[TOTAL_BYTES] = { 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00 };
	
	// placing memory address of the new function in RIP + 0 for the jmp instruction above
	void * funcPointer = &otherFunc;
	memcpy( detour + 6, &newFunctionName, 8);
	
	for (int i = 0; i < TOTAL_BYTES; i++)
		printf("%X ", detour[i]);
	
	// save bytes that will be written over incase restoration is needed (and unhooking)
	memcpy( deletedBytes, functionName, TOTAL_BYTES);

	// fixing memory protection + writing the jmp instruction in the start of the function 
	VirtualProtect((LPVOID) functionName, 4096, PAGE_READWRITE, &oldProtect);
	memcpy( functionName, detour, TOTAL_BYTES); 
	VirtualProtect((LPVOID) functionName, 4096, oldProtect, &oldProtect);
	
	return 0;
}


BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ){

	switch (ul_reason_for_call){
	case DLL_PROCESS_ATTACH:
		patchingHook( pMessageBox, otherFunc);
		break;
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:
		break;
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}
