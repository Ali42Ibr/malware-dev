/*

 hardware breakpoint

 DR0-DR3 debug address
 set one of them with the address to place a breakpoint one

 DR7
 Controls debug process
 Bits 0 2 4 6 when set to 1 turn on DRn (2^n)
 Bits 16-29(not all of them) define what type of breakpoint we want. 00 means on instruction execution (at the address)

 So to setup a hook on a function (you can do 4 at a time) place the addr of the func you want hooked in DRn
 and place a 1 in bit 2^n and place 0 in the 2 bits corresponding to your DR (0:16,17 1:20,21 2:24,25 3:28,29)

 To remove a breakpoint 0 out the DRn and place 0 in the DR7 2^n spot

 Likely extremly easy to detect.. especially if used in non-debegging context  

*/

#include <stdio.h>
#include <windows.h>

#pragma comment (lib, "User32.lib")

// turning breakpoint on / of
void breakpoint(void * function, BOOLEAN set){
	
	CONTEXT ctx = { 0 };
	ctx.ContextFlags = CONTEXT_ALL;
	GetThreadContext( GetCurrentThread(), &ctx);
	
	if (set){
	
		ctx.Dr0 = (DWORD64) &MessageBoxA;
		ctx.Dr7 = (ctx.Dr7 | 1);
		ctx.Dr7 = (ctx.Dr7 & ~(1 << 16));
		ctx.Dr7 = (ctx.Dr7 & ~(1 << 17));
	} else {
		ctx.Dr0 = NULL;
		ctx.Dr7 &= ~(1 << 0);	
	}
	
	ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;
	SetThreadContext( GetCurrentThread(), &ctx);
	
}

int hookedMsg(HWND rcx,LPCSTR rdx,LPCSTR r8, UINT r9, DWORD stck1, DWORD stck2){
		
	MessageBoxA( rcx, "new text", r8, r9);
	
	//turn hook back on
	breakpoint( &MessageBoxA, 1);

	return NULL;
}

LONG WINAPI vectorHandler(struct _EXCEPTION_POINTERS *ExceptionInfo){
	
	if (ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_GUARD_PAGE_VIOLATION ){
		
		return EXCEPTION_CONTINUE_EXECUTION;
	}
	
	// EFLAG bit 16 is used to resume execution after breakpoint is reached 
	ExceptionInfo->ContextRecord->EFlags |= (1 << 16);
	
	// remove breakpoint to go to hooked function
	ExceptionInfo->ContextRecord->Dr0 = NULL;
	ExceptionInfo->ContextRecord->Dr7 &= ~(1 << 0);
	ExceptionInfo->ContextRecord->Rip = (DWORD64)&hookedMsg;

    return EXCEPTION_CONTINUE_EXECUTION;
}

int main() {
	
	// setting breakpoint on messagebox
	
	HANDLE hVector = AddVectoredExceptionHandler( 1, &vectorHandler);
	
	breakpoint( &MessageBoxA, 1);
	
	MessageBoxA( NULL, "lpText", "lpCaption", MB_OK);
	MessageBoxA( NULL, "lpText", "lpCaption", MB_OK);
	MessageBoxA( NULL, "lpText", "lpCaption", MB_OK);

	RemoveVectoredExceptionHandler(hVector);

	breakpoint( &MessageBoxA, 0);
	
	MessageBoxA( NULL, "lpText", "lpCaption", MB_OK);
	
	return 0;
}
