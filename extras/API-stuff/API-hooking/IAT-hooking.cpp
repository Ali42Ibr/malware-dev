/*

 API hooking techniques are used in a variety of malware, anti-virus, and a variety of other applications. 
 These techniques involve controlling or redirecting function behaviour such as that the code execution is 
 completely different than what it should be. 
 
 API hooking is ued in EDRs by checking the parameters and usage of specific potentially dangerous function.
 But fortunately, since these EDRs are in user-space we have just as much control over these functions as they do.
 So by simply redirecting the EDRs redirection, we can revert its control and bypass it. This is just one of the 
 many scenarios where API hooking is useful.

 This method just modifies the import table itself, so that the original function name points to the modified
 function address instead. This is done at loading time, and the original function pointer is saved so it can be reused.

 Compile as dll and attatch/inject into victim process.

*/

#include <stdio.h>
#include <windows.h>
#pragma comment(lib, "user32.lib")

//a pointer to the unhooked function 
int (WINAPI * pMessageBox)(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType) = MessageBox;

int hookedMessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType) {
	
	pMessageBox(hWnd, "NO MSGBOX FOR U", lpCaption, uType);
	
	return 0;
	
}

//1 == hook, 0 == unhook
int IATHookUnhook(char * moduleName, char * functionName, void * newFunctionName, int hookOrUnhook){
	
	//getting address of import table
	ULONG_PTR baseAddr = (ULONG_PTR) GetModuleHandle(NULL);
	ULONG_PTR addrA = baseAddr;
	
	addrA = (ULONG_PTR)(((IMAGE_DOS_HEADER *)(addrA))->e_lfanew + baseAddr);
	addrA = (ULONG_PTR)(&((IMAGE_NT_HEADERS *)(addrA))->OptionalHeader);
	addrA = (ULONG_PTR)((IMAGE_DATA_DIRECTORY)(((IMAGE_OPTIONAL_HEADER *)(addrA))->DataDirectory[1])).VirtualAddress;
	addrA = (ULONG_PTR)((char *)addrA + baseAddr);
	
	//searching for required module, not pretty but just simple parsing thorugh ILT
	int found = -1;
	for (int i = 0; ((((IMAGE_IMPORT_DESCRIPTOR *)(addrA))[i+1].Name)+(char *)baseAddr) != 0; i++){
		if (!stricmp(((((IMAGE_IMPORT_DESCRIPTOR *)(addrA))[i].Name)+(char *)baseAddr),moduleName)){
			found = i;
			break;
		}
	}
	
	if (found == -1)
		return 1;
	
	//thunk contains the addresses of the functions
	//ogThunk contains the names of the functions
	IMAGE_THUNK_DATA * thunk = (IMAGE_THUNK_DATA *)(((IMAGE_IMPORT_DESCRIPTOR *)(addrA))[found].FirstThunk + (char *)baseAddr);
	IMAGE_THUNK_DATA * ogThunk = (IMAGE_THUNK_DATA *)(((IMAGE_IMPORT_DESCRIPTOR *)(addrA))[found].OriginalFirstThunk + (char *)baseAddr);

	//if the function is found, just replace the address in the IAT to the new function..
	for (int i = 0; thunk[i].u1.Function != 0; i++){
		if (!stricmp(((IMAGE_IMPORT_BY_NAME *)(ogThunk[i].u1.AddressOfData + (char *)baseAddr))->Name,
		functionName)){
			ULONGLONG oldFunction = thunk[i].u1.Function;
			DWORD oldProtect = 0;
			VirtualProtect((LPVOID) &thunk[i].u1.Function, 4096, PAGE_READWRITE, &oldProtect);
			if (hookOrUnhook){
				(thunk[i].u1.Function) = (ULONGLONG)newFunctionName;
			} else {
				(thunk[i].u1.Function) = oldFunction;
			}
			VirtualProtect((LPVOID) &thunk[i].u1.Function, 4096, oldProtect, &oldProtect);	
			return 0;
		}
	}
	
	return 1;	
	
	
}

//for simplicity, i guess..
int IATHook(char * moduleName, char * functionName, void * newFunctionName){
	IATHookUnhook(moduleName, functionName, newFunctionName, 1 );
	return 0;
}

int IATUnhook(char * moduleName, char * functionName, void * newFunctionName){	
	IATHookUnhook(moduleName, functionName, newFunctionName, 0 );
	return 0;
}

BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ){

	switch (ul_reason_for_call){
	case DLL_PROCESS_ATTACH:
		IATHook("USER32.dll", "MessageBoxA", hookedMessageBox);
		break;
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:
		break;
	case DLL_PROCESS_DETACH:
		IATUnhook("USER32.dll", "MessageBoxA", hookedMessageBox);
		break;
	}
	return TRUE;
}
