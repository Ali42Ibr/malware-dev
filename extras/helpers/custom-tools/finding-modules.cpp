//possible usage
//after getting initial execution on a system, you could search different processes on the system to see which ones 
//are already talking to the internet/network. This makes the connection much less suspicious then something like Exel or Word
//executing powershell reverse shells and network calls.
//for example: ws2_32.dll

//these functions will search for a module 


#include <windows.h>
#include <tlhelp32.h> 
#include <stdio.h>
#include <psapi.h>

int classicFindModule(int PID, char * mName, char * pName);
int enumProcModule(int PID, char * mName, char * pName);
int vQuery(int PID, char * mName, char * pName);

//go to process project file to see more
int searchThroughProcess( char * mName ){
	
	HANDLE hProcessSnap;
	HANDLE hProcess;
	PROCESSENTRY32 pe32;
	DWORD dwPriorityClass;
	
	// Take a snapshot of all processes in the system.
	hProcessSnap = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 );
	
	pe32.dwSize = sizeof( PROCESSENTRY32 );
	
	do {
		vQuery(pe32.th32ProcessID, mName, pe32.szExeFile);	  
	} while( Process32Next( hProcessSnap, &pe32 ) );

	  CloseHandle( hProcessSnap );
	  return -1;
	
}	

// uses regular snapshot module, easy to follow
int classicFindModule(int PID, char * mName, char * pName){

	HANDLE hModuleSnap = INVALID_HANDLE_VALUE; 
	MODULEENTRY32 me32; 

	hModuleSnap = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, PID ); 
	if(hModuleSnap == INVALID_HANDLE_VALUE) return -1;
	me32.dwSize = sizeof( MODULEENTRY32 ); 
		
	if(!Module32First(hModuleSnap, &me32)){ 
		CloseHandle(hModuleSnap);
		return -1; 
	} 
	
	do { 
		if (!stricmp(mName, me32.szModule)){
			printf("Process %s with PID %d is using %s\n", pName, PID, me32.szModule);
		}
	} while( Module32Next( hModuleSnap, &me32 ) ); 
	 
	CloseHandle( hModuleSnap ); 
	return 1;
} 

// uses psapi functions
int enumProcModule(int PID, char * mName, char * pName){
	
	HANDLE hProc = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, PID);
	HMODULE moduleArray[1024];
	HMODULE expandedModuleArray[2048];
	DWORD cb = sizeof(moduleArray);
	DWORD cb2 = sizeof(expandedModuleArray);
	DWORD bytesNeeded;
	char lpBaseName[100];
	DWORD nSize = sizeof(lpBaseName);
	DWORD err;
	int bigger = 0;
	
	err = EnumProcessModulesEx( hProc, (HMODULE *)moduleArray, cb, &bytesNeeded, 0x03); //0x03 = list all modules (x64 and x32)
	if (err = 0){
		printf("return: %X error:%X\n", err, GetLastError());
		return -1;
	}
	if ( cb < bytesNeeded ) {
		err = EnumProcessModulesEx( hProc, (HMODULE *)expandedModuleArray, cb2, &bytesNeeded, 0x03); 
		if (err = 0){
			printf("return: %X error:%X\n", err, GetLastError());
			return -1;
		}
		bigger = 1;
	}
	
	for (int i = 0; i < bytesNeeded/sizeof(HMODULE); i++){
		if (bigger)
			GetModuleBaseNameA( hProc, expandedModuleArray[i], lpBaseName, nSize);
		else
			GetModuleBaseNameA( hProc, moduleArray[i], lpBaseName, nSize);			
		if (!stricmp( mName, lpBaseName))
			printf("Process %s with PID %d is using %s\n", pName, PID, lpBaseName);
	}
	
	return 0;
}

// a third way 
int vQuery(int PID, char * mName, char * pName){

	HANDLE hProc = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, PID);
	MEMORY_BASIC_INFORMATION buffer;
	char lpBaseName[100];
	DWORD nSize = sizeof(lpBaseName);
	char * currAddr = 0;
	
    while (VirtualQueryEx( hProc, currAddr, &buffer, sizeof(buffer)) == sizeof(MEMORY_BASIC_INFORMATION)) {
		if ((buffer.AllocationBase == buffer.BaseAddress) && (buffer.BaseAddress != NULL)) {
			if(GetModuleBaseNameA( hProc, (HMODULE) buffer.AllocationBase, lpBaseName, nSize)){
				if (!stricmp(lpBaseName, mName))
					printf("Process %s with PID %d is using %s\n", pName, PID, lpBaseName);
			}
		}
		currAddr += buffer.RegionSize;
	}
	
	return 0;
}


int main(){
	
	searchThroughProcess("ws2_32.dll");
	return 1;
}
