/*
 Mostly windows supplied code, WMI initialization and basics found at: https://learn.microsoft.com/en-us/windows/win32/wmisdk/example-creating-a-wmi-application
 Object sink basic implementation: https://learn.microsoft.com/en-us/windows/win32/wmisdk/iwbemobjectsink
 
 This program will query WMI each second, asking whether a process has been created. It will then return information about the process.
 In a malware standpoint, this can be used to check for specific processes that can aid in privilege escalation / persistance as well as
 anti-detection. For example 

*/

#define _WIN32_DCOM
#include <iostream>
using namespace std;
#include <comdef.h>
#include <Wbemidl.h>
#pragma comment(lib, "wbemuuid.lib")

/*
 Object sink default structure, according to windows:
 The IWbemObjectSink interface creates a sink interface that can receive all types of notifications within the WMI programming model.

 This object will be sent to WMI service with the request query to be monitored, that way whenever the condition requested is met
 WMI knows where and how to send back data, properly structured for us to recieve it.

*/

class QuerySink : public IWbemObjectSink
{
    LONG m_lRef;
    bool bDone; 

public:
    QuerySink() { m_lRef = 0; }
   ~QuerySink() { bDone = TRUE; }

	// Addref called when pointer is initialized
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();        
	// Release is called whenever a pointer is no longer needed
    virtual HRESULT STDMETHODCALLTYPE 
        QueryInterface(REFIID riid, void** ppv);

    virtual HRESULT STDMETHODCALLTYPE Indicate( 
            /* [in] */
            LONG lObjectCount,
            /* [size_is][in] */
            IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray
            );
        
    virtual HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ LONG lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam
            );
};


ULONG QuerySink::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG QuerySink::Release()
{
    LONG lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT QuerySink::QueryInterface(REFIID riid, void** ppv)
{
    if (riid == IID_IUnknown || riid == IID_IWbemObjectSink)
    {
        *ppv = (IWbemObjectSink *) this;
        AddRef();
        return WBEM_S_NO_ERROR;
    }
    else return E_NOINTERFACE;
}


// properly parses the returned objects (in pArray) from WMI
HRESULT QuerySink::Indicate(long lObjectCount, IWbemClassObject **pArray) {
	HRESULT hr = S_OK;
	_variant_t vtProp;

	//all code here is directly copied from Sektor7 Advanced course, from WMI monitor class
	// Walk through all returned objects
    for (int i = 0 ; i < lObjectCount ; i++) {
		IWbemClassObject * pObj = pArray[i];
		
		// First, get a pointer to the object properties
		hr = pObj->Get(_bstr_t(L"TargetInstance"), 0, &vtProp, 0, 0);
		if (!FAILED(hr)) {
			
			// Then, get a pointer to the process object' interface to query its properties
			IUnknown * pProc = vtProp;
			hr = pProc->QueryInterface(IID_IWbemClassObject, (void **) &pObj);
			if (SUCCEEDED(hr)) {
				_variant_t pVal;

				// print process name
				hr = pObj->Get(L"Name", 0, &pVal, NULL, NULL);
				if (SUCCEEDED(hr)) {
					if ((pVal.vt==VT_NULL) || (pVal.vt==VT_EMPTY))
						printf("Name: %s\n", (pVal.vt==VT_NULL) ? "NULL" : "EMPTY");
					else
						printf("Name: %S\n", pVal.bstrVal);
					
					// if pVal.bstrVal == "target process name" -> inject/kill/suspend/...
				}
				VariantClear(&pVal);
				
				// print process ID
				hr = pObj->Get(L"Handle", 0, &pVal, NULL, NULL);
				if (SUCCEEDED(hr)) {
					if ((pVal.vt == VT_NULL) || (pVal.vt == VT_EMPTY))
						printf("PID: %s\n", (pVal.vt == VT_NULL) ? "NULL" : "EMPTY");
					else
						printf("PID: %S\n", pVal.bstrVal);
				}
				VariantClear(&pVal);

				// print Executable Path
				hr = pObj->Get(L"ExecutablePath", 0, &pVal, NULL, NULL);
				if (SUCCEEDED(hr)) {
					if ((pVal.vt==VT_NULL) || (pVal.vt==VT_EMPTY))
						printf("ExecutablePath: %s\n", (pVal.vt==VT_NULL) ? "NULL" : "EMPTY");
					else
						printf("ExecutablePath: %S\n", pVal.bstrVal);
				}
				VariantClear(&pVal);	

				// print command line
				hr = pObj->Get(L"CommandLine", 0, &pVal, NULL, NULL);
				if (SUCCEEDED(hr)) {
					if ((pVal.vt == VT_NULL) || (pVal.vt == VT_EMPTY))
						printf("CommandLine: %s\n", (pVal.vt == VT_NULL) ? "NULL" : "EMPTY");
					else
						printf("CommandLine: %S\n", pVal.bstrVal);
				}
				VariantClear(&pVal);				
			}
		}
		VariantClear(&vtProp);
    }

    return WBEM_S_NO_ERROR;
}

HRESULT QuerySink::SetStatus(
            /* [in] */ LONG lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam
        )
{
	
    printf("QuerySink::SetStatus hResult = 0x%X\n", hResult);
    return WBEM_S_NO_ERROR;
	
}



int main(int argc, char **argv)
{
    HRESULT hres;

	// starting some windows stuff to begin communicating with WMI
    // Initialize COM.
    hres =  CoInitializeEx(0, COINIT_MULTITHREADED); 
    if (FAILED(hres))
    {
        return 1;              // Program has failed.
    }

    // Initialize 
    hres =  CoInitializeSecurity(
        NULL,     
        -1,      // COM negotiates service                  
        NULL,    // Authentication services
        NULL,    // Reserved
        RPC_C_AUTHN_LEVEL_DEFAULT,    // authentication
        RPC_C_IMP_LEVEL_IMPERSONATE,  // Impersonation
        NULL,             // Authentication info 
        EOAC_NONE,        // Additional capabilities
        NULL              // Reserved
        );

                      
    if (FAILED(hres))
    {
        CoUninitialize();
        return 1;          // Program has failed.
    }

    // Obtain the initial locator to Windows Management
    // on a particular host computer.
    IWbemLocator *pLoc = 0;

    hres = CoCreateInstance(
        CLSID_WbemLocator,             
        0, 
        CLSCTX_INPROC_SERVER, 
        IID_IWbemLocator, (LPVOID *) &pLoc);
 
    if (FAILED(hres)){
        CoUninitialize();
        return 1;       // Program has failed.
    }

    IWbemServices *pSvc = 0;

    // Connect to the root\cimv2 namespace with the
    // current user and obtain pointer pSvc
    // to make IWbemServices calls.


	// here pSvc will contain the WMI services interface, this pointer will be used to call WMI related functions later on
    hres = pLoc->ConnectServer(
        
        _bstr_t(L"ROOT\\CIMV2"), // WMI namespace
        NULL,                    // User name
        NULL,                    // User password
        0,                       // Locale
        NULL,                    // Security flags                 
        0,                       // Authority       
        0,                       // Context object
        &pSvc                    // IWbemServices proxy
        );                              
    
    if (FAILED(hres)){
        pLoc->Release();     
        CoUninitialize();
        return 1;                // Program has failed.
    }
    // Set the IWbemServices proxy so that impersonation
    // of the user (client) occurs.
    hres = CoSetProxyBlanket(
       
       pSvc,                         // the proxy to set
       RPC_C_AUTHN_WINNT,            // authentication service
       RPC_C_AUTHZ_NONE,             // authorization service
       NULL,                         // Server principal name
       RPC_C_AUTHN_LEVEL_CALL,       // authentication level
       RPC_C_IMP_LEVEL_IMPERSONATE,  // impersonation level
       NULL,                         // client identity 
       EOAC_NONE                     // proxy capabilities     
    );

    if (FAILED(hres))
    {
        pSvc->Release();
        pLoc->Release();     
        CoUninitialize();
        return 1;               // Program has failed.
    }


    // Use the IWbemServices pointer to make requests of WMI. 
    // Make requests here:


	// here is where we can put some functional code, actually interacting with WMI 

	// create new querysink object 
	QuerySink * qSink = new QuerySink;
	qSink->AddRef();

	// WMIsvc function ExecNotificationQueryAsync is used to request WMI to call the Indicator function in our object 
	// each time the provided query occurs. 
	HRESULT res = pSvc->ExecNotificationQueryAsync( bstr_t("WQL"), 
	bstr_t("SELECT * FROM __InstanceCreationEvent WITHIN 1 WHERE TargetInstance ISA 'Win32_Process'"),
	WBEM_FLAG_SEND_STATUS,
	NULL,
	qSink);	
	
	// hangs process, notifications occuring until skipped
    getchar();
 
    // Cleanup
    // ========
    pSvc->Release();
    pLoc->Release();
    //pEnumerator->Release();  
    
    CoUninitialize();

    return 0;   // Program successfully completed.
}