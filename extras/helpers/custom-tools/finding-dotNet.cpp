/*
 Finding .NET applications based on the existance of \\BaseNamedObjects\\Cor_Private_IPCBlock_v4_$PID section
 .NET applications contain already allocated RWX regions, perfect for writing without needing VirtualAlloc
 or other memory allocation functions. Problem is, its very possible the application will over-write the shellcode  
 if placed there, must keep re-writing or change the protections after writing, which would probably crash the process
*/

#include <windows.h>
#include <stdio.h>
#include <winternl.h>
#include <psapi.h>

typedef NTSTATUS (NTAPI * NtGetNextProcess_t)(
   HANDLE ProcessHandle,
   ACCESS_MASK DesiredAccess,
   ULONG HandleAttributes,
   ULONG Flags,
   PHANDLE NewProcessHandle
);

typedef NTSTATUS (NTAPI * NtOpenSection_t)(
	PHANDLE            SectionHandle,
	ACCESS_MASK        DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes
);

void extractString( char * string){
	int j = 0;
	int slash = 0;
	while(string[j] != 0){
		if (string[j] == '\\') slash=j+1;
		j++;
	}
	
	memcpy( string, (char *)string + slash, strlen(string) - slash + 1);
	
	
}

int checkRWX(HANDLE hProc){
	
	MEMORY_BASIC_INFORMATION memBasicInfo;
	LPVOID addr = 0;
	
	while(VirtualQueryEx( hProc, addr, &memBasicInfo, sizeof(MEMORY_BASIC_INFORMATION ))){
	
		//printf("%p\n", hProc);
		
		if (memBasicInfo.State == MEM_COMMIT && memBasicInfo.Type == MEM_PRIVATE && memBasicInfo.Protect == PAGE_EXECUTE_READWRITE){
			printf("[Base address of region %p] (%dKB)\n", addr, memBasicInfo.RegionSize/1000);
		}
		addr = (char *)addr + memBasicInfo.RegionSize;
	}
	
	return 0;
}


int main(){
	
	NtGetNextProcess_t pNtGetNextProcess = (NtGetNextProcess_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtGetNextProcess");
	NtOpenSection_t pNtOpenSection = (NtOpenSection_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtOpenSection");
	
	//loop through process, check for open section with the .NET name
	
	HANDLE cProc = NULL;
	OBJECT_ATTRIBUTES objAttributes;
	UNICODE_STRING sectionName;
	HANDLE hSection;
	int PID;
	wchar_t wPID[10];
	wchar_t initialString[] =  L"\\BaseNamedObjects\\Cor_Private_IPCBlock_v4_";
	char dotNetName[1000];
	HANDLE dotNetHandle;

/*
	sectionName.Buffer = 
	sectionName.Length = wcslen(sectionName.Buffer) * sizeof(wchar_t);
	sectionName.MaximumLength = sectionName.Length + 1;		
*/
	
    pNtGetNextProcess(cProc, MAXIMUM_ALLOWED, 0, 0, &cProc);
    while (cProc) {
		PID = GetProcessId(cProc);
		pNtGetNextProcess(cProc, MAXIMUM_ALLOWED, 0, 0, &cProc);
		
		swprintf_s(wPID, L"%d", PID);
		//printf("%S\n", wPID);
		sectionName.Buffer = (PWSTR) malloc(500);
		memcpy(sectionName.Buffer, initialString, wcslen(initialString)*2);
		memcpy( (char*)sectionName.Buffer + wcslen(initialString)*2, wPID, wcslen(wPID)*2+1);

		sectionName.Length = wcslen(sectionName.Buffer) * sizeof(wchar_t);
		sectionName.MaximumLength = sectionName.Length + 1;				
	
		InitializeObjectAttributes( &objAttributes, &sectionName, OBJ_CASE_INSENSITIVE, NULL, NULL);
		if (!pNtOpenSection( &hSection, SECTION_QUERY, &objAttributes)){
			dotNetHandle = OpenProcess( PROCESS_DUP_HANDLE |PROCESS_QUERY_INFORMATION, NULL, PID);
			GetProcessImageFileNameA( dotNetHandle, dotNetName, 1000);
			extractString(dotNetName);
			printf("Found .NET! (%s %d)\n [free private RWX regions]\n", dotNetName, PID);
			checkRWX(dotNetHandle);
			CloseHandle(dotNetHandle);
		}
	}
	
	return 0;
}	
	

