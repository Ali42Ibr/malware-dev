//different methods to find processes, i can't imagine AVs look for process finding? Regardless it was interesting to find 
//NT functions for process finding

#include <stdio.h>
#include <windows.h>
#include <tlhelp32.h>
#include <psapi.h>
#include <tchar.h>
#include <wtsapi32.h>

#pragma comment(lib, "Wtsapi32.lib")

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;

typedef LONG KPRIORITY;

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation = 0,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemProcessInformation = 5,
    SystemProcessorPerformanceInformation = 8,
    SystemInterruptInformation = 23,
    SystemExceptionInformation = 33,
    SystemRegistryQuotaInformation = 37,
    SystemLookasideInformation = 45,
    SystemCodeIntegrityInformation = 103,
    SystemPolicyInformation = 134,
} SYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    BYTE Reserved1[48];
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    PVOID Reserved2;
    ULONG HandleCount;
    ULONG SessionId;
    PVOID Reserved3;
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG Reserved4;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    PVOID Reserved5;
    SIZE_T QuotaPagedPoolUsage;
    PVOID Reserved6;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
    LARGE_INTEGER Reserved7[6];
} SYSTEM_PROCESS_INFORMATION;

typedef NTSTATUS (NTAPI * NtQuerySystemInformation_t)(
  SYSTEM_INFORMATION_CLASS SystemInformationClass,
  PVOID                    SystemInformation,
  ULONG                    SystemInformationLength,
  PULONG                   ReturnLength
);

typedef NTSTATUS (NTAPI * NtGetNextProcess_t)(
   HANDLE ProcessHandle,
   ACCESS_MASK DesiredAccess,
   ULONG HandleAttributes,
   ULONG Flags,
   PHANDLE NewProcessHandle
);

int classicFindProcess( char * pName){
	
	HANDLE hProcessSnap;
	HANDLE hProcess;
	PROCESSENTRY32 pe32;
	DWORD dwPriorityClass;
	
	// Take a snapshot of all processes in the system.
	hProcessSnap = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 );
	
	pe32.dwSize = sizeof( PROCESSENTRY32 );
	
	do {
		
		if (!stricmp( pName, pe32.szExeFile)) {
			CloseHandle( hProcessSnap );
			return pe32.th32ProcessID;
		}
	  
	} while( Process32Next( hProcessSnap, &pe32 ) );

	  CloseHandle( hProcessSnap );
	  return -1;
}

int enumProcess( char * pName){
	
    DWORD aProcesses[2000], cbNeeded, cProcesses;
    unsigned int i;
	HANDLE hProcess;
	HMODULE hMod;
	TCHAR szProcessName[1000] = {0};
	
	
    if ( !EnumProcesses( aProcesses, sizeof(aProcesses), &cbNeeded ))  return 1;
	
	cProcesses = cbNeeded / sizeof(DWORD);
    
	for ( i = 0; i < cProcesses; i++ ) {
        if( aProcesses[i] != 0 ) {
			hProcess = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, aProcesses[i] );
			if (NULL != hProcess ){
				if ( EnumProcessModules( hProcess, &hMod, sizeof(hMod), &cbNeeded) ) {
				GetModuleBaseName( hProcess, hMod, szProcessName, sizeof(szProcessName)/sizeof(TCHAR) );
				}
			}		

			if (!stricmp( pName, szProcessName)){
				CloseHandle( hProcess );
				return aProcesses[i];
			}
			CloseHandle( hProcess );
        }
    }

    return -1;
}


//used for remote process enumeration, can be used pretty easy locally as well  :)
//https://learn.microsoft.com/en-us/windows/win32/api/wtsapi32/

int wtsEnumerate( char * pName ){
	
	WTS_PROCESS_INFOA * pInfoArray;
	DWORD pCount;
	
	if (!WTSEnumerateProcessesA( WTS_CURRENT_SERVER_HANDLE , 0, 1, &pInfoArray, &pCount))
		return -1;
	
	for (int i = 0; i < pCount; i++)
		if (!stricmp( pName, pInfoArray[i].pProcessName)) return pInfoArray[i].ProcessId;	
	
	return -1;
}

//winternal function to get a bunch of systeminfo:
//https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation

//peculiar way to get processes, but quit simple nontheless
int ntQuerySystemInformationProcess( wchar_t * pName){
	
	NtQuerySystemInformation_t pNtQuerySystemInformation = (NtQuerySystemInformation_t) GetProcAddress(GetModuleHandle("ntdll.dll"),"NtQuerySystemInformation");
	
	SYSTEM_PROCESS_INFORMATION systemInfoPointer[1000];
	ULONG returnLength;
	
	if(pNtQuerySystemInformation( (SYSTEM_INFORMATION_CLASS)SystemProcessInformation, &systemInfoPointer, sizeof(systemInfoPointer), &returnLength))
		return -1;
	
	SYSTEM_PROCESS_INFORMATION * csysinfo = systemInfoPointer;
	
	do {
		csysinfo = (SYSTEM_PROCESS_INFORMATION *)((char *)csysinfo + csysinfo->NextEntryOffset);
		if (!wcsicmp(csysinfo->ImageName.Buffer, pName)) return (WORD)csysinfo->UniqueProcessId;
		} while (csysinfo->NextEntryOffset != 0);
	return -1;
}

//(undocumented) reference: https://googleprojectzero.blogspot.com/2015/05/
int ntGetNextProcess( char * pName ){
	
	size_t plen = strlen(pName);
	HANDLE currentHandle = 0;
	char testPName[200] = {0};
	
	NtGetNextProcess_t pNtGetNextProcess = (NtGetNextProcess_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtGetNextProcess");
	while (!pNtGetNextProcess(currentHandle, MAXIMUM_ALLOWED, NULL, NULL, &currentHandle)){
		GetProcessImageFileNameA( currentHandle, testPName, sizeof(testPName));
		if (!stricmp((char *)testPName + strlen(testPName) - plen, pName)) return GetProcessId(currentHandle);
	}		

   return -1;
	
}

	



int main(){
	
	char pName[] = "notepad.exe";
	int PID = ntGetNextProcess(pName);

	if (PID < 0) return 1;
	
	printf("%d\n", PID);
	
	return 0;

}