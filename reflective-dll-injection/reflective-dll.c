/*
Reflective DLL sample code, heavily inspired by https://github.com/stephenfewer/ReflectiveDLLInjection.
Please use at your own risk, this was a fun little project and it is very unstable!
I mainly wrote this to practice internal windows stuff, please feel free to let me know if there are any mistakes or things 
I could do better.
*/

#include "reflective-dll.h"


//returns caller's memory address
__declspec(noinline)
void * returnCaller(void)
{
   return _ReturnAddress();
}

extern "C" __declspec(dllexport) void * ReflectiveLoader (VOID);

void * ReflectiveLoader(VOID ){
		
	VirtualAlloc_t pVirtualAlloc;
	LoadLibraryA_t pLoadLibraryA;
	GetProcAddress_t pGetProcAddress;
	NtFlushInstructionCache_t pNtFlushInstructionCache;
	
	ULONG_PTR imageBase_new;
	ULONG_PTR callerAddress;
	IMAGE_DOS_HEADER * pDos_header;
	IMAGE_NT_HEADERS * pNt_header;
	IMAGE_OPTIONAL_HEADER optional_header;
	
	PEB * pPeb;
	PEB_LDR_DATA * pLdr;
	LDR_DATA_TABLE_ENTRY * pLdr_entry;
	ULONG_PTR kernel32_address;
	ULONG_PTR ntdll_address;
	
	//finding PE headers
	callerAddress = (ULONG_PTR) returnCaller();
	
	while (1) {
		callerAddress--;
		pDos_header = (IMAGE_DOS_HEADER *) callerAddress;
		if (pDos_header->e_magic == 0x5A4D){
			 pNt_header = (IMAGE_NT_HEADERS *) (callerAddress + pDos_header->e_lfanew);
			 if (pNt_header->Signature == 0x4550)
				 break;
		}
	}
	
	optional_header = pNt_header->OptionalHeader;

	//finding PEB address
	#if defined(_M_X64) // x64
	pPeb = (PEB *) __readgsqword(0x60);
	#else // x86
	pPeb = (PEB *) __readfsdword(0x60);
	#endif
	
	pLdr = pPeb->Ldr;
	
	//finding base addresses for kernel32 and ntdll 
	for (LIST_ENTRY * lEntry = pLdr->InMemoryOrderModuleList.Flink ; lEntry != &pLdr->InMemoryOrderModuleList; lEntry = lEntry->Flink){
		pLdr_entry = (LDR_DATA_TABLE_ENTRY *)((char *) lEntry - 0x10);
		if (!wcscmp( L"KERNEL32.DLL", pLdr_entry->BaseDllName.Buffer)){
			kernel32_address = (ULONG_PTR) pLdr_entry->DllBase;
		}
		if (!wcscmp( L"ntdll.dll", pLdr_entry->BaseDllName.Buffer)){
			ntdll_address = (ULONG_PTR) pLdr_entry->DllBase;
		}
	}
	
	
	//finding runtime function addresses

	//necessary header extraction
	IMAGE_DOS_HEADER * kernel32_base  = (IMAGE_DOS_HEADER *) kernel32_address;
	IMAGE_NT_HEADERS * nt = (IMAGE_NT_HEADERS *)((char *)kernel32_address + kernel32_base->e_lfanew);
	IMAGE_OPTIONAL_HEADER op = nt->OptionalHeader;
	IMAGE_EXPORT_DIRECTORY * export_dir = (IMAGE_EXPORT_DIRECTORY *)((char *)kernel32_address + 
	op.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
	IMAGE_THUNK_DATA * name_directory = (IMAGE_THUNK_DATA *) ((char *)kernel32_address + export_dir->AddressOfNames);
	
	//searching through export table for function adresses (by name)
	for (int i = 0; i < export_dir->NumberOfNames; i++){
		DWORD funcNameAddress =  (DWORD)((IMAGE_THUNK_DATA *)((char *)name_directory + i*sizeof(DWORD)))->u1.AddressOfData;
		if (!strcmp("GetProcAddress", funcNameAddress + (char *)kernel32_address)){
			IMAGE_THUNK_DATA * function_directory = (IMAGE_THUNK_DATA *) ((char *)kernel32_address + export_dir->AddressOfFunctions);
			DWORD getproc = (DWORD)((IMAGE_THUNK_DATA *)((char *)function_directory + i*sizeof(DWORD)))->u1.AddressOfData;
			pGetProcAddress = (GetProcAddress_t) (getproc + (char *)kernel32_address);
		}
		
		if (!strcmp("VirtualAlloc", funcNameAddress + (char *)kernel32_address)){
			IMAGE_THUNK_DATA * function_directory = (IMAGE_THUNK_DATA *) ((char *)kernel32_address + export_dir->AddressOfFunctions);
			DWORD getproc = (DWORD)((IMAGE_THUNK_DATA *)((char *)function_directory + i*sizeof(DWORD)))->u1.AddressOfData;
			pVirtualAlloc = (VirtualAlloc_t) (getproc + (char *)kernel32_address);
		}
		
		if (!strcmp("LoadLibraryA", funcNameAddress + (char *)kernel32_address)){
			IMAGE_THUNK_DATA * function_directory = (IMAGE_THUNK_DATA *) ((char *)kernel32_address + export_dir->AddressOfFunctions);
			DWORD getproc = (DWORD)((IMAGE_THUNK_DATA *)((char *)function_directory + i*sizeof(DWORD)))->u1.AddressOfData;
			pLoadLibraryA = (LoadLibraryA_t) (getproc + (char *)kernel32_address);
		}
	}
	
	//same but with NTDLL
	IMAGE_DOS_HEADER * ntdll_base  = (IMAGE_DOS_HEADER *) ntdll_address;
	nt = (IMAGE_NT_HEADERS *)((char *)ntdll_address + ntdll_base->e_lfanew);
	op = nt->OptionalHeader;
	export_dir = (IMAGE_EXPORT_DIRECTORY *)((char *)ntdll_address + 
	op.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
	name_directory = (IMAGE_THUNK_DATA *) ((char *)ntdll_address + export_dir->AddressOfNames);

	for (int i = 0; i < export_dir->NumberOfNames; i++){
		DWORD funcNameAddress =  (DWORD)((IMAGE_THUNK_DATA *)((char *)name_directory + i*sizeof(DWORD)))->u1.AddressOfData;
		if (!strcmp("NtFlushInstructionCache", funcNameAddress + (char *)ntdll_address)){
			IMAGE_THUNK_DATA * function_directory = (IMAGE_THUNK_DATA *) ((char *)ntdll_address + export_dir->AddressOfFunctions);
			DWORD getproc = (DWORD)((IMAGE_THUNK_DATA *)((char *)function_directory + (i+1)*sizeof(DWORD)))->u1.AddressOfData;
			pNtFlushInstructionCache = (NtFlushInstructionCache_t) (getproc + (char *)ntdll_address);
		}
	}	
		
	//copying over headers and sections
	
	//allocating needed memory for image
	imageBase_new = (ULONG_PTR) pVirtualAlloc( 0, optional_header.SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	
	//copying the headers to newly allocated memory
	memcpy((void *)imageBase_new, (void *)callerAddress, optional_header.SizeOfHeaders);
	
	//copying sections to newly allocated memory
	IMAGE_SECTION_HEADER * section_header = (IMAGE_SECTION_HEADER *) ((char *)imageBase_new + 
	(pDos_header->e_lfanew + sizeof(IMAGE_NT_HEADERS)));

	for (int i = 0; i < pNt_header->FileHeader.NumberOfSections; i++){		
		memcpy((char *)imageBase_new + section_header[i].VirtualAddress, (char *)callerAddress + section_header[i].PointerToRawData,
		section_header[i].SizeOfRawData);
	}
	
	//filling up the IAT (import stuff)
	nt = (IMAGE_NT_HEADERS *)((char *)imageBase_new + ((IMAGE_DOS_HEADER *) imageBase_new)->e_lfanew);
	op = nt->OptionalHeader;

	IMAGE_IMPORT_DESCRIPTOR * import_dir = (IMAGE_IMPORT_DESCRIPTOR *)((char *)imageBase_new + 
	op.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

	//necessary (?) stuff for architecture specifics
	#if _WIN64
		QWORD importLookupTable;
		QWORD * importAddressTable;
		QWORD * ra;
		QWORD ordinalMask = IMAGE_ORDINAL_FLAG64;
	#else
		DWORD importLookupTable;
		DWORD * importAddressTable;
		DWORD * ra;
		DWORD ordinalMask = IMAGE_ORDINAL_FLAG32;		
	#endif
	
	char * dllName = "1";
	for (int i = 0; import_dir[i].Name != 0x00; i++){
		dllName = (char *)imageBase_new + import_dir[i].Name;
		HMODULE hDLL = pLoadLibraryA(dllName);
		importLookupTable = import_dir[i].OriginalFirstThunk;
		//getchar();
		ra = (void *) (importLookupTable + (char *)imageBase_new);
		char * functionName = "1";
		int j;
		importAddressTable = (void *)((char *)imageBase_new + import_dir[i].FirstThunk);
		
		for( j=0 ; ra[j] != 0; j++){
			FARPROC functionAddress = 0;
			functionName = ((IMAGE_IMPORT_BY_NAME *)((char *)imageBase_new + ra[j]))->Name;	
			if (ra[j] & ordinalMask)
				functionAddress = pGetProcAddress(hDLL, (LPCSTR) (ra[j] & 0xffff));
			else 
				functionAddress = pGetProcAddress(hDLL, functionName);
			importAddressTable[j] = (QWORD)functionAddress;
		}	
	}
	
	//relocations 
	IMAGE_RELOCATION * basereloc = (IMAGE_RELOCATION *)((char *)imageBase_new + 
	op.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);

	DWORD size_basereloc = op.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
	
	int j = 0;
	DWORD pageRVA = 1;
	DWORD blockSize = 0;
	WORD offset;
	int totalBlockSize = 0;
	int type;
	int realOffset;
	ULONG_PTR final_address;
	ULONG_PTR difference;
	
	difference = (ULONG_PTR)((char *)imageBase_new - op.ImageBase);

	
	while (1){
		basereloc = (IMAGE_RELOCATION *)((char *)basereloc + blockSize);
		pageRVA = basereloc->VirtualAddress;
		blockSize = basereloc->SymbolTableIndex;
		
		if (!pageRVA)
			break;
		
		for (j = 0; j < (blockSize-8)/2; j++){
			offset = ((IMAGE_RELOCATION *)((char *)basereloc + j*sizeof(WORD)))->Type;
			if (offset){
				type = (offset&0xF000) / 0x1000;
				realOffset = (offset & 0x0FFF);
				if (type > 0){
					final_address = (ULONG_PTR)((char *)imageBase_new + realOffset + pageRVA);
					*(DWORD *)(final_address) += (DWORD)difference;
				}
			}
		}
	}

	pNtFlushInstructionCache( (HANDLE)-1, NULL, 0 );


	ULONG_PTR new_entry = (ULONG_PTR)((char *)imageBase_new + op.AddressOfEntryPoint);
	((DLLMAIN)new_entry)( (HINSTANCE)imageBase_new, DLL_PROCESS_ATTACH, NULL );

	return 0;

	
}


// The DLL main in this file should only be used if no other custom main is required 

/*
BOOL WINAPI DllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved ) {

	switch ( fdwReason ) {
			case DLL_PROCESS_ATTACH:
					break;
			case DLL_THREAD_ATTACH:
					break;
			case DLL_THREAD_DETACH:
					break;
			case DLL_PROCESS_DETACH:
					break;
			}
	return TRUE;
}
*/

