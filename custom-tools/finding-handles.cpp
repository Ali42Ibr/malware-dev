// finding handles in system
// can be used to duplicate already open handles

#include <windows.h>
#include <stdio.h>
# include <psapi.h>

#define SystemHandleInformation 16
#define INITIAL_LENGTH 10000

typedef enum _OBJECT_INFORMATION_CLASS {
    ObjectBasicInformation = 0,
    ObjectNameInformation = 1,
    ObjectTypeInformation = 2,
    ObjectTypesInformation = 3,
    ObjectHandleFlagInformation = 4,
    ObjectSessionInformation = 5,
    ObjectSessionObjectInformation = 6,
    MaxObjectInfoClass = 7
} OBJECT_INFORMATION_CLASS;


typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;

typedef struct _OBJECT_NAME_INFORMATION {
  UNICODE_STRING          Name;
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;	

typedef struct __PUBLIC_OBJECT_TYPE_INFORMATION {
  UNICODE_STRING TypeName;
  ULONG          Reserved[22];
} PUBLIC_OBJECT_TYPE_INFORMATION, *PPUBLIC_OBJECT_TYPE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
	USHORT 	UniqueProcessId;
	USHORT 	CreatorBackTraceIndex;
	UCHAR 	ObjectTypeIndex;
	UCHAR 	HandleAttributes;
	USHORT 	HandleValue;
	PVOID 	Object;
	ULONG 	GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION {
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef NTSTATUS (NTAPI * NtQuerySystemInformation_t)(
    ULONG SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);

typedef NTSTATUS (NTAPI * NtQueryObject_t)(
	HANDLE                   Handle,
	OBJECT_INFORMATION_CLASS ObjectInformationClass,
	PVOID                    ObjectInformation,
	ULONG                    ObjectInformationLength,
	PULONG                   ReturnLength
);

typedef NTSTATUS (NTAPI * NtDuplicateObject_t)(
	HANDLE      SourceProcessHandle,
	HANDLE      SourceHandle,
	HANDLE      TargetProcessHandle,
	PHANDLE     TargetHandle,
	ACCESS_MASK DesiredAccess,
	ULONG       HandleAttributes,
	ULONG       Options
);

// go through all handles in handle list
// for each handle, try to open the process that opened it. Need query_info and duplicate rights
// can see handle properties such as type and name
// for process handles can see whats the opened process and rights

void extractString( char * string){
	int j = 0;
	int slash = 0;
	while(string[j] != 0){
		if (string[j] == '\\') slash=j+1;
		j++;
	}
	
	memcpy( string, (char *)string + slash, strlen(string) - slash + 1);
	
	
}

int main(){
	
	// init functions
	NtQuerySystemInformation_t pNtQuerySystemInformation = (NtQuerySystemInformation_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQuerySystemInformation");
	NtQueryObject_t pNtQueryObject = (NtQueryObject_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQueryObject");
	NtDuplicateObject_t pNtDuplicateObject = (NtDuplicateObject_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "NtDuplicateObject");
	
	ULONG returnLength;
	SYSTEM_HANDLE_INFORMATION * sHandleBuffer;
	ULONG requiredLength = INITIAL_LENGTH;
	PUBLIC_OBJECT_TYPE_INFORMATION objectInfo[1000];
	OBJECT_NAME_INFORMATION nameInfo[1000] = {0};
	
	//need to dynamically allocate space, if not enough space querysysteminfo will return an error > 0
	//placing entire handle list in memory
	while(pNtQuerySystemInformation(SystemHandleInformation, sHandleBuffer, requiredLength, &returnLength)){
		if (requiredLength - INITIAL_LENGTH) VirtualFree( sHandleBuffer, requiredLength, MEM_RELEASE);
		requiredLength += requiredLength;
		sHandleBuffer = (SYSTEM_HANDLE_INFORMATION *) VirtualAlloc( 0, requiredLength, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	}
	
	SYSTEM_HANDLE_TABLE_ENTRY_INFO * handleArray =  (SYSTEM_HANDLE_TABLE_ENTRY_INFO *)(sHandleBuffer->Handles);
	DWORD previousPID = 0;
	DWORD deniedPID = 0;
	HANDLE pDuplicate; //duplicate process
	HANDLE hDuplicate; //duplicate handle
	char pDuplicateName[1000];
	
	
	//going through each handle one by one
	for (int i = 0; i < sHandleBuffer->NumberOfHandles; i++){
		
		if ( deniedPID == handleArray[i].UniqueProcessId) continue;

		pDuplicate = OpenProcess( PROCESS_DUP_HANDLE |PROCESS_QUERY_INFORMATION, NULL, handleArray[i].UniqueProcessId);
		//couldn't duplicate parent process (not actually parent, just the proces which requested the handle
		//skip this handle, saves PID to skip the coming ones as well
		if (!pDuplicate){
			deniedPID = handleArray[i].UniqueProcessId;
			continue;
		}
		
		//get name of parent process
		GetProcessImageFileNameA( pDuplicate, pDuplicateName, 1000);
		extractString( (char *)pDuplicateName);
		
		//try to duplicate handle, request system to give you the same handle
		DWORD err = pNtDuplicateObject( pDuplicate, (HANDLE)handleArray[i].HandleValue, GetCurrentProcess(), &hDuplicate, 0, 0, DUPLICATE_SAME_ACCESS);
		if (err){
			CloseHandle(pDuplicate);
			continue;
		}
		
        //pipes hang sometimes NtQueryObject, since i won't need them I've left them out for now, still all their information can be found above
		if(GetFileType(hDuplicate) == FILE_TYPE_PIPE) {
			continue;
		}
		
		//check and print information about the handle
		DWORD ntstatus = pNtQueryObject( hDuplicate, (OBJECT_INFORMATION_CLASS) ObjectTypeInformation, &objectInfo, 0, &returnLength);
		ntstatus = pNtQueryObject(hDuplicate, (OBJECT_INFORMATION_CLASS) ObjectTypeInformation, &objectInfo, returnLength, &returnLength);
		if (ntstatus){
			CloseHandle(pDuplicate);
			continue;
		}
	
	
		ntstatus = pNtQueryObject( hDuplicate, (OBJECT_INFORMATION_CLASS) ObjectNameInformation, &nameInfo, 0, &returnLength);
		ntstatus = pNtQueryObject(hDuplicate, (OBJECT_INFORMATION_CLASS) ObjectNameInformation, &nameInfo, returnLength, &returnLength);		
		if (ntstatus){
			CloseHandle(pDuplicate);
			continue;
		}
		
		char handleProcessName[1000]; //contains the name of the requested process/thread
		int handlePID; //contains the PID of the requested process/thread, this is what you would use if you need to steal the handle
		
		
		//to check which process or thread is being requested in the handle, we need to open the process/thread to find the name
		if (!wcsicmp(objectInfo->TypeName.Buffer,L"Process")){
			handlePID = GetProcessId(hDuplicate);
			GetProcessImageFileNameA(OpenProcess( PROCESS_DUP_HANDLE |PROCESS_QUERY_INFORMATION, NULL, handlePID), handleProcessName, 1000);
			extractString(handleProcessName);
			printf("[%s (%d)] HANDLE [%X] [%S %d %s] \n", pDuplicateName, handleArray[i].UniqueProcessId, handleArray[i].HandleValue, objectInfo->TypeName.Buffer, handlePID,  handleProcessName);
			CloseHandle(hDuplicate);
		} else if (!wcsicmp(objectInfo->TypeName.Buffer,L"Thread")){
			handlePID = GetProcessIdOfThread(hDuplicate);
			if (handlePID != handleArray[i].UniqueProcessId){
			GetProcessImageFileNameA(OpenProcess( PROCESS_DUP_HANDLE |PROCESS_QUERY_INFORMATION, NULL, handlePID), handleProcessName, 1000);
			extractString(handleProcessName);
			printf("[%s (%d)] HANDLE [%X] [%S %d %s] \n", pDuplicateName, handleArray[i].UniqueProcessId, handleArray[i].HandleValue, objectInfo->TypeName.Buffer, handlePID,  handleProcessName);
			CloseHandle(hDuplicate);
			}
		} else {
			printf("[%s (%d)] HANDLE [%X] [%S %S] \n", pDuplicateName, handleArray[i].UniqueProcessId, handleArray[i].HandleValue, objectInfo->TypeName.Buffer, nameInfo->Name.Buffer);
		}
		
		CloseHandle(pDuplicate);
		
	}
}