// still in progress

// coff loader
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <strsafe.h>
#include <shlwapi.h>
#include "ali.h"

#pragma comment(lib, "Shlwapi.lib")

char undef[] = "__UNDEFINED";
char *  GOT = NULL;
int Gindex = 0;
void 				(* entrypoint)(void);


int loadObject(unsigned char * buffer, int buffer_size){
	

	
	// original structures for parsing
	COFF_HEADER * originalCoffHeader = (COFF_HEADER *) buffer;	
	COFF_SECTION_HEADER * originalSectionHeader = (COFF_SECTION_HEADER *) (buffer +  sizeof(COFF_HEADER));
	COFF_RELOCATION_HEADER * originalRelocationHeader;
	COFF_SYMBOL_TABLE * originalSymbolTable = (COFF_SYMBOL_TABLE *) (buffer +  originalCoffHeader->PointerToSymbolTable);
	
	// new in memory structures, changed slightly for loading
	
	// COFF_INMEMORY structure will be used to save all relevant info about each section 
	// (basically just raw data & ptr to relocation table)
	COFF_INMEMORY * sections = (COFF_INMEMORY *)calloc( originalCoffHeader->NumberOfSections, sizeof(COFF_INMEMORY));
	
	// inMemorySymbolTable will contain a copy of the original symbol table
	COFF_SYMBOL * inMemorySymbolTable;
	DWORD sz_symboltable = originalCoffHeader->NumberOfSymbols * 18;
	
	for (int i = 0; i < originalCoffHeader->NumberOfSections; i++){
		
		sections[i].Index = i;
		
		// allocate memory for raw data
		sections[i].InMemoryAddress = VirtualAllocEx( GetCurrentProcess(), 0, originalSectionHeader->SizeOfRawData, MEM_RESERVE | MEM_COMMIT, 
		(originalSectionHeader->Characteristics & IMAGE_SCN_CNT_CODE) ? PAGE_EXECUTE_READWRITE : PAGE_READWRITE);
		if (!sections[i].InMemoryAddress){
			printf("Couldn't allocate exiting\n");
			printf("%X\n", GetLastError());
			return 1;
		}
		
		// write raw data 
		if(!WriteProcessMemory( GetCurrentProcess(), sections[i].InMemoryAddress, (buffer + originalSectionHeader->PointerToRawData), originalSectionHeader->SizeOfRawData, NULL)){
			VirtualFree( GetCurrentProcess(), sections[i].InMemoryAddress, buffer_size, MEM_RELEASE);
			printf("Couldn't write exiting\n");
			printf("%X\n", GetLastError());
			return 1;
		}
		
		// if section contains relocations allocate it, write it, and save it in its structure
		if (originalSectionHeader->PointerToRelocations){
			sections[i].PointerToRelocations = VirtualAllocEx( GetCurrentProcess(), 0, originalSectionHeader->NumberOfRelocations * 10, MEM_RESERVE | MEM_COMMIT, 	
			PAGE_READWRITE);
			sections[i].NumberOfRelocations = originalSectionHeader->NumberOfRelocations;
			if (!sections[i].PointerToRelocations){
				printf("Couldn't allocate exiting\n");
				printf("%X\n", GetLastError());
				return 1;
			}
			
			if(!WriteProcessMemory( GetCurrentProcess(), sections[i].PointerToRelocations, (buffer + originalSectionHeader->PointerToRelocations), 
			originalSectionHeader->NumberOfRelocations * 10, NULL)){
				printf("Couldn't write exiting\n");
				printf("%X\n", GetLastError());		
				return 1;
			}
		}
		
		originalSectionHeader = (COFF_SECTION_HEADER *) ((char *)originalSectionHeader + sizeof(COFF_SECTION_HEADER));

			
	}
		
	inMemorySymbolTable = calloc(originalCoffHeader->NumberOfSymbols , sizeof(COFF_SYMBOL));
	COFF_SYMBOL_TABLE * cst = originalSymbolTable;
	for (int i = 0; i < originalCoffHeader->NumberOfSymbols; i++){
		
		// this combination of values corresponds to an undefined name
		if (cst->SectionNumber == 0 && cst->StorageClass == 0) {
			memcpy( inMemorySymbolTable[i].Name, undef, strlen(undef)+1); 
		} else {
			// if the first 4 bits in the name are 0, we should grab the name from the string table
			if (cst->Name.Zeros == 0){
				strcpy(inMemorySymbolTable[i].Name, cst->Name.Offset + (char *)buffer +  originalCoffHeader->PointerToSymbolTable +  (originalCoffHeader->NumberOfSymbols*18));
			// otherwise just copy over the 8 byte name
			} else {
				strncpy(&inMemorySymbolTable[i].Name, cst->Name.ShortName, 8);
			}
		}
		
		inMemorySymbolTable[i].Index = i;
		inMemorySymbolTable[i].SectionNumber = cst->SectionNumber;
		inMemorySymbolTable[i].Value = cst->Value;
		inMemorySymbolTable[i].StorageClass = cst->StorageClass;
		inMemorySymbolTable[i].InMemoryAddress = NULL;
		
		cst = (char *)cst + 18;
	}	
	
	// resolve symbols 
	char * GOT = VirtualAlloc(NULL, 2048, MEM_COMMIT | MEM_RESERVE | MEM_TOP_DOWN, PAGE_READWRITE);
	char * DLLname;
	char * funcName;
	int locationOfSign;
	
	for (int i = 0; i < originalCoffHeader->NumberOfSymbols; i++){
		
		// skip if undefined name, sections can only be 0 if external or > 0 < FFFF if internal
		if (strstr(inMemorySymbolTable[i].Name, undef)){
			inMemorySymbolTable[i].InMemoryAddress = NULL;
			continue;
		}			
		
		// skip if section number is not real
		if (inMemorySymbolTable[i].SectionNumber == 0xffff) {
			inMemorySymbolTable[i].InMemoryAddress = NULL;
			continue;
		}
		
		// if contains __imp_ and section == 0 then its an external function
		if (strstr(inMemorySymbolTable[i].Name, "__imp_")) {
			// if there is no $ in the function then its kernel32 
			if (!strchr(inMemorySymbolTable[i].Name, '$')) {
				DLLname = "KERNEL32";
				funcName = inMemorySymbolTable[i].Name + strlen("__imp_"); //function name is after __imp_ characters, ends with NULL byte as MSDN documentation
			// if there is a $ the dllName comes before it, and the function name comes after it
			}  else {
			//dll name is after imp, function name is after $
				DLLname = inMemorySymbolTable[i].Name  + strlen("__imp_");
				strtok_s(inMemorySymbolTable[i].Name , "$", &funcName);
			}
		
			//load DLL
			HANDLE h = LoadLibraryA(DLLname);
			
			if (h) {
				// in memory address will be saved as function address
				inMemorySymbolTable[i].InMemoryAddress = GetProcAddress(h, funcName);
				
				// copy address of memory address into next avaliable space in GOT 
				memcpy(GOT + (Gindex * 8), &inMemorySymbolTable[i].InMemoryAddress, sizeof(uint64_t));
				
				// increase index and take note of the address inside the coff symbol structure 
				inMemorySymbolTable[i].GOTaddress = GOT + (Gindex * 8);
				Gindex++;
			}
			
		} else {
			// for internal symbols, the inmemoryaddress is the section address of the current entry + the value in the entry
			inMemorySymbolTable[i].InMemoryAddress = sections[inMemorySymbolTable[i].SectionNumber - 1].InMemoryAddress + inMemorySymbolTable[i].Value;
			if (!strncmp(inMemorySymbolTable[i].Name, "go", 4)) {
				entrypoint = inMemorySymbolTable[i].InMemoryAddress;
			}			
		}	
	}
	
	for (int i = 0; i < originalCoffHeader->NumberOfSymbols; i++){
		
		printf("%X %s %p\n", inMemorySymbolTable[i].Index,inMemorySymbolTable[i].Name, inMemorySymbolTable[i].InMemoryAddress);
		
	}
	
	// Step 7. Fix relocations
	uint64_t what64 = 0;		// 64-bit "what" to write ("what" means - what data to save in the relocated memory)
	int32_t what32 = 0;			// 32-bit "what" to write
	char * where = NULL;		// "where" to write (which memory needs updating)
	int64_t offset64 = 0;		// storage for offsets at relocation position, 64- and 32-bit
	int32_t offset32 = 0;

	for (int i = 0 ; i < originalCoffHeader->NumberOfSections ; i++ ) {
		if (sections[i].PointerToRelocations == 0)
			continue;
		else
			for (int j = 0 ; j < sections[i].NumberOfRelocations ; j++ ) {
				COFF_RELOCATION_HEADER * coff_reloc_ptr = (COFF_RELOCATION_HEADER *)sections[i].PointerToRelocations;			
				where = NULL;
				switch (coff_reloc_ptr->Type) {
					case IMAGE_REL_AMD64_ADDR64: {		// Type 0x1
						where = sections[i].InMemoryAddress + coff_reloc_ptr->VirtualAddress; //destination location
						//memcpy(&offset64, where, sizeof(int32_t)); //ofset64 = destination location 
						what64 = inMemorySymbolTable[coff_reloc_ptr->SymbolTableIndex].InMemoryAddress + where;
						memcpy(where, &what64, sizeof(uint64_t));
						printf("reached here x1");
						break;
					}
					case IMAGE_REL_AMD64_ADDR32NB: { 	// Type 0x3
						where = sections[i].InMemoryAddress + coff_reloc_ptr->VirtualAddress;
						memcpy(&offset32, where, sizeof(int32_t));
						what32 = offset32 + (inMemorySymbolTable[coff_reloc_ptr->SymbolTableIndex].InMemoryAddress) - ((int32_t) where + 4);
						memcpy(where, &what32, sizeof(uint32_t));
						printf("reached here x3");
						break;
					}
					case IMAGE_REL_AMD64_REL32: { 		// Type 0x4
						where = sections[i].InMemoryAddress + coff_reloc_ptr->VirtualAddress;
						memcpy(&offset32, where, sizeof(int32_t));
						if (inMemorySymbolTable[coff_reloc_ptr->SymbolTableIndex].GOTaddress != NULL)
							what32 = (int32_t)((inMemorySymbolTable[coff_reloc_ptr->SymbolTableIndex].GOTaddress) - ((int32_t) where + 4));
						else
							what32 = offset32 + (inMemorySymbolTable[coff_reloc_ptr->SymbolTableIndex].InMemoryAddress) - ((int32_t) where + 4);
						memcpy(where, &what32, sizeof(uint32_t));
						printf("reached here x4");
						break;
					}
					case IMAGE_REL_AMD64_REL32_4: { 	// Type 0x8
						where = sections[i].InMemoryAddress + coff_reloc_ptr->VirtualAddress;
						memcpy(&offset32, where, sizeof(int32_t));
						what32 = offset32 + (inMemorySymbolTable[coff_reloc_ptr->SymbolTableIndex].InMemoryAddress) - ((int32_t) where + 4 + 4);
						//DEBUG_PRINT("WHERE = %p\n", where);
						//DEBUG_PRINT("DATA = %x\n", what32);
						memcpy(where, &what32, sizeof(uint32_t));
						printf("reached here x8");
						break;
					}
					default: {
						printf("[!] ERROR! Reloc type %#x is not supported (SECT = %d : REL = %d)\n", coff_reloc_ptr->Type, i, j);
						return -1;
					}
				}
				coff_reloc_ptr = (char *)coff_reloc_ptr + 10;
			}
	}
	
	
	printf("[+] Everything's set up! Launching the beastie...\n\n");

	if (entrypoint != NULL){
		printf("Reached");
		__debugbreak();
		entrypoint();
	}else {
		return -1;
	}
	
	printf("Done");
	
	return 0;	
}
	
	


int main( int argc, int argv[]) {

	//read file for loading
	HANDLE hFile;
	
	hFile = CreateFile("test.o", GENERIC_READ, NULL, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		
	if (hFile == INVALID_HANDLE_VALUE) { 
        printf("Unable to open file\n");
        return 1; 
	}
		
	DWORD fs = GetFileSize(hFile, NULL);	
	unsigned char * buffer = VirtualAllocEx( GetCurrentProcess(), 0, fs * sizeof(DWORD), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	ReadFile(hFile, buffer, fs * sizeof(DWORD), NULL, NULL);
	
	loadObject(buffer, fs * sizeof(DWORD)); 
	

	return 0;


}
