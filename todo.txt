***

Userland rootkit: Use global hooking or WMI querying to find out if something like process hacker or task manager has been launched, file explorer or cmd has been launched. Then we inject api hooking dlls into these programs so that they are unable to properly view/detect what we want as hidden.

Then use API hooking to redirect NTDLL functions involved in process querying / file or folder enumeration. For example if process being looked at is the one we want hidden, just don't return anything.. 

Good example: https://github.com/bytecode77/r77-rootkit

***

Global hooking: Used to detect as mention above^ look at WMI project found here 
https://cocomelonc.github.io/tutorial/2022/05/16/malware-pers-5.html
https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa

***

Modifying PEB to hide details in our PE such as modules loaded, process information etc.
This is good vs static analysis and runtime analysis, as defenders won't be able to easily realize the PEB has been changed, unless they actually go through the reversed code

Example: https://www.cynet.com/attack-techniques-hands-on/defense-evasion-techniques-peb-edition/

***

No patch hooking

---
Guard pages: Windows has an exception event which can be set on specific areas of memory. Once these areas of memory is reached, code is redirected to an exception handler that can do something with the exception. The handler function recieves the type of exception and a context variable which includes a bunch of information about where the exception came from (registers etc.). 

This can be easily used as a kind of hooking function, proper return can be handled using memory inspection.

Example: https://github.com/codereversing/guardpage_hook/blob/master/MemoryBreakpoint.cpp

---
Hardware breakpoints: Inolves Intel's implemenation of breakpoints using registers. 

As described in: https://www.codereversing.com/archives/594
The x86 and x64 architectures provide a set of registers that are useful for debugging. Four debug registers, Dr0, Dr1, Dr2, and Dr3 can hold an address to set a breakpoint on. These breakpoints can be enabled or disabled through the debug control register, Dr7. When a breakpoint has been hit, there is a debug status register, Dr6, that holds information about the breakpoint.

Essentially works like guard pages, an exception event is executed once an address in one of the debug registers (0-3) is reached. Checkout the link above for more info.

***

Super crude explanation of gargoyle so i can remember it for later

Situation: Evading memory analysis.

Definition of memory analysis: Memory forensics is the process of capturing the running memory of a device and then analyzing the captured output for evidence of malicious software.

Exploit in summary: It is common that memory analysists and their tools only scan executable sections of memory in order to save time and resources. A tool like gargoyle exploits this situation by 
having the code it wants to execute marked as non-executable most of the time.


Step 1

The shellcode of gargoyle encapsulates the malicious code and is placed in a non-executable area of the stack. 

Step 2

APC queue is utilized to momentarily execute a different area of the code. This is done using CreateWaitableTimer which creates a timer, and SetWaitableTimer which sets the address
where execution will go to after the timer is over. 

Step 3

The address jumped to in the APC function described above is an already executable section of code, this area of code, using some magic, will go to VirtualProtectEx and change the protections
of the gargoyle shellcode to executable. It then returns to non-executable.

***

NinjaGaurd Windows AV bypass

Hooks CreateProcessInternal since Windows will check a process' memory if it invokes this function. Simply waits a few seconds (until the scan is over) before actually executes it. 

***


